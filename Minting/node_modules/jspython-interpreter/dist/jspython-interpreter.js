
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jspython = {}));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    function parseDatetimeOrNull(value) {
        if (!value) {
            return null;
        }
        if (typeof value === 'number') {
            return new Date(value);
        }
        if (value instanceof Date && !isNaN(value.valueOf())) {
            return value;
        }
        // only string values can be converted to Date
        if (typeof value !== 'string') {
            return null;
        }
        var strValue = String(value);
        if (!strValue.length) {
            return null;
        }
        var parseMonth = function (mm) {
            if (!mm || !mm.length) {
                return NaN;
            }
            var m = parseInt(mm, 10);
            if (!isNaN(m)) {
                return m - 1;
            }
            // make sure english months are coming through
            if (mm.startsWith('jan')) {
                return 0;
            }
            if (mm.startsWith('feb')) {
                return 1;
            }
            if (mm.startsWith('mar')) {
                return 2;
            }
            if (mm.startsWith('apr')) {
                return 3;
            }
            if (mm.startsWith('may')) {
                return 4;
            }
            if (mm.startsWith('jun')) {
                return 5;
            }
            if (mm.startsWith('jul')) {
                return 6;
            }
            if (mm.startsWith('aug')) {
                return 7;
            }
            if (mm.startsWith('sep')) {
                return 8;
            }
            if (mm.startsWith('oct')) {
                return 9;
            }
            if (mm.startsWith('nov')) {
                return 10;
            }
            if (mm.startsWith('dec')) {
                return 11;
            }
            return NaN;
        };
        var correctYear = function (yy) {
            if (yy < 100) {
                return yy < 68 ? yy + 2000 : yy + 1900;
            }
            else {
                return yy;
            }
        };
        var validDateOrNull = function (yyyy, month, day, hours, mins, ss) {
            if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) {
                return null;
            }
            var dd = new Date(yyyy, month, day, hours, mins, ss, 0);
            return !isNaN(dd.valueOf()) ? dd : null;
        };
        var strTokens = strValue
            .replace('T', ' ')
            .toLowerCase()
            .split(/[: /-]/);
        var dt = strTokens.map(parseFloat);
        // try ISO first
        var d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);
        if (d) {
            return d;
        }
        // then UK
        d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[1]), dt[0], dt[3] || 0, dt[4] || 0, dt[5] || 0);
        if (d) {
            return d;
        }
        // then US
        d = validDateOrNull(correctYear(dt[2]), parseMonth(strTokens[0]), correctYear(dt[1]), dt[3] || 0, dt[4] || 0, dt[5] || 0);
        if (d) {
            return d;
        }
        return null;
    }
    function getImportType(name) {
        if (name.startsWith('/') || name.startsWith('./')) {
            return name.endsWith('.json') ? 'json' : 'jspyModule';
        }
        return 'jsPackage';
    }
    function jspyErrorMessage(error, module, line, column, message) {
        return "".concat(error, ": ").concat(module, "(").concat(line, ",").concat(column, "): ").concat(message);
    }
    /** @class */ ((function (_super) {
        __extends(JspyTokenizerError, _super);
        function JspyTokenizerError(module, line, column, message) {
            var _this = _super.call(this) || this;
            _this.module = module;
            _this.line = line;
            _this.column = column;
            _this.message = message;
            _this.message = jspyErrorMessage('JspyTokenizerError', module, line, column, message);
            Object.setPrototypeOf(_this, JspyTokenizerError.prototype);
            return _this;
        }
        return JspyTokenizerError;
    })(Error));
    var JspyParserError = /** @class */ (function (_super) {
        __extends(JspyParserError, _super);
        function JspyParserError(module, line, column, message) {
            var _this = _super.call(this) || this;
            _this.module = module;
            _this.line = line;
            _this.column = column;
            _this.message = message;
            _this.message = jspyErrorMessage('JspyParserError', module, line, column, message);
            Object.setPrototypeOf(_this, JspyParserError.prototype);
            return _this;
        }
        return JspyParserError;
    }(Error));
    var JspyEvalError = /** @class */ (function (_super) {
        __extends(JspyEvalError, _super);
        function JspyEvalError(module, line, column, message) {
            var _this = _super.call(this) || this;
            _this.module = module;
            _this.line = line;
            _this.column = column;
            _this.message = message;
            _this.message = jspyErrorMessage('JspyEvalError', module, line, column, message);
            Object.setPrototypeOf(_this, JspyEvalError.prototype);
            return _this;
        }
        return JspyEvalError;
    }(Error));
    var JspyError = /** @class */ (function (_super) {
        __extends(JspyError, _super);
        function JspyError(module, line, column, name, message) {
            var _this = _super.call(this) || this;
            _this.module = module;
            _this.line = line;
            _this.column = column;
            _this.name = name;
            _this.message = message;
            _this.message = jspyErrorMessage('JspyError', module || 'name.jspy', line, column, message);
            Object.setPrototypeOf(_this, JspyError.prototype);
            return _this;
        }
        return JspyError;
    }(Error));

    var OperationTypes;
    (function (OperationTypes) {
        OperationTypes[OperationTypes["Arithmetic"] = 0] = "Arithmetic";
        OperationTypes[OperationTypes["Assignment"] = 1] = "Assignment";
        OperationTypes[OperationTypes["Comparison"] = 2] = "Comparison";
        OperationTypes[OperationTypes["Logical"] = 3] = "Logical";
        OperationTypes[OperationTypes["Membership"] = 4] = "Membership";
    })(OperationTypes || (OperationTypes = {}));
    var OperatorsMap = new Map([
        ['+', OperationTypes.Arithmetic],
        ['-', OperationTypes.Arithmetic],
        ['*', OperationTypes.Arithmetic],
        ['/', OperationTypes.Arithmetic],
        ['%', OperationTypes.Arithmetic],
        ['**', OperationTypes.Arithmetic],
        ['//', OperationTypes.Arithmetic],
        ['>', OperationTypes.Comparison],
        ['>=', OperationTypes.Comparison],
        ['==', OperationTypes.Comparison],
        ['!=', OperationTypes.Comparison],
        ['<>', OperationTypes.Comparison],
        ['<', OperationTypes.Comparison],
        ['<=', OperationTypes.Comparison],
        ['and', OperationTypes.Logical],
        ['or', OperationTypes.Logical],
        // "not", OperationTypes.Logical],
        // "not in", OperationTypes.Logical],
        ['in', OperationTypes.Membership],
        ['=', OperationTypes.Assignment],
        ['+=', OperationTypes.Assignment],
        ['-=', OperationTypes.Assignment],
        ['*=', OperationTypes.Assignment],
        ['/=', OperationTypes.Assignment],
        ['++', OperationTypes.Assignment],
        ['--', OperationTypes.Assignment]
    ]);
    var OperationFuncs = new Map([
        ['+', (function (l, r) { return arithmeticOperation(l, r, '+'); })],
        ['-', (function (l, r) { return arithmeticOperation(l, r, '-'); })],
        ['/', (function (l, r) { return arithmeticOperation(l, r, '/'); })],
        ['*', (function (l, r) { return arithmeticOperation(l, r, '*'); })],
        ['%', (function (l, r) { return arithmeticOperation(l, r, '%'); })],
        ['**', (function (l, r) { return arithmeticOperation(l, r, '**'); })],
        ['//', (function (l, r) { return arithmeticOperation(l, r, '//'); })],
        ['>', (function (l, r) { return comparissonOperation(l, r, '>'); })],
        [
            '>=',
            (function (l, r) { return comparissonOperation(l, r, '>='); })
        ],
        ['<', (function (l, r) { return comparissonOperation(l, r, '<'); })],
        [
            '<=',
            (function (l, r) { return comparissonOperation(l, r, '<='); })
        ],
        [
            '==',
            (function (l, r) { return comparissonOperation(l, r, '=='); })
        ],
        [
            '!=',
            (function (l, r) { return comparissonOperation(l, r, '!='); })
        ],
        [
            '<>',
            (function (l, r) { return comparissonOperation(l, r, '<>'); })
        ],
        ['and', (function (l, r) { return logicalOperation(l, r, 'and'); })],
        ['or', (function (l, r) { return logicalOperation(l, r, 'or'); })],
        // "not" as ExpressionOperators, ((l, r) => logicalOperation(l, r, "not")) as ExpressionOperation],
        // "not in" as ExpressionOperators, ((l, r) => logicalOperation(l, r, "not in")) as ExpressionOperation],
        ['in', (function (l, r) { return membershipOperation(l, r, 'in'); })]
    ]);
    function membershipOperation(l, r, op) {
        if (typeof l === 'string') {
            return l.includes(String(r));
        }
        if (Array.isArray(l)) {
            return l.includes(r);
        }
        throw new Error("Unknown operation '".concat(op, "'"));
    }
    function logicalOperation(l, r, op) {
        switch (op) {
            case 'and':
                return l && r;
            case 'or':
                return l || r;
        }
        throw new Error("Unknown operation '".concat(op, "'"));
    }
    function comparissonOperation(l, r, op) {
        switch (op) {
            case '==':
                return l === r;
            case '!=':
                return l !== r;
            case '<>':
                return l !== r;
            case '>':
                return l > r;
            case '<':
                return l < r;
            case '>=':
                return l >= r;
            case '<=':
                return l <= r;
        }
        throw new Error("Unknown operation '".concat(op, "'"));
    }
    function arithmeticOperation(l, r, op) {
        switch (op) {
            case '+':
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return l + r;
            case '-':
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return l - r;
            case '*':
                return l * r;
            case '/':
                return l / r;
            case '%':
                return l % r;
            case '**':
                return Math.pow(l, r);
        }
        throw new Error("Unknown operation '".concat(op, "'"));
    }

    var TokenTypes;
    (function (TokenTypes) {
        TokenTypes[TokenTypes["Identifier"] = 0] = "Identifier";
        TokenTypes[TokenTypes["Keyword"] = 1] = "Keyword";
        TokenTypes[TokenTypes["Separator"] = 2] = "Separator";
        TokenTypes[TokenTypes["Operator"] = 3] = "Operator";
        TokenTypes[TokenTypes["LiteralNumber"] = 4] = "LiteralNumber";
        TokenTypes[TokenTypes["LiteralBool"] = 5] = "LiteralBool";
        TokenTypes[TokenTypes["LiteralString"] = 6] = "LiteralString";
        TokenTypes[TokenTypes["LiteralNull"] = 7] = "LiteralNull";
        TokenTypes[TokenTypes["Comment"] = 8] = "Comment";
    })(TokenTypes || (TokenTypes = {}));
    function isTokenTypeLiteral(tokenType) {
        return (tokenType === TokenTypes.LiteralString ||
            tokenType === TokenTypes.LiteralNumber ||
            tokenType === TokenTypes.LiteralBool ||
            tokenType === TokenTypes.LiteralNull);
    }
    function getTokenType(token) {
        return token[1][0];
    }
    function getTokenValue(token) {
        return token ? token[0] : null;
    }
    function getTokenLoc(token) {
        return token[1].subarray(1);
    }
    function getStartLine(token) {
        return token[1][1];
    }
    function getStartColumn(token) {
        return token[1][2];
    }
    function getEndLine(token) {
        return token[1][3];
    }
    function getEndColumn(token) {
        return token[1][4];
    }
    function splitTokensByIndexes(tokens, sepIndexes) {
        var result = [];
        if (!tokens.length) {
            return [];
        }
        var start = 0;
        for (var i = 0; i < sepIndexes.length; i++) {
            var ind = sepIndexes[i];
            if (getTokenValue(tokens[start - 1]) === '[') {
                start = start - 1;
            }
            result.push(tokens.slice(start, ind));
            start = ind + 1;
        }
        if (getTokenValue(tokens[start - 1]) === '[') {
            start = start - 1;
        }
        result.push(tokens.slice(start, tokens.length));
        return result;
    }
    function splitTokens(tokens, separator) {
        if (!tokens.length) {
            return [];
        }
        var sepIndexes = findTokenValueIndexes(tokens, function (value) { return value === separator; });
        return splitTokensByIndexes(tokens, sepIndexes);
    }
    function findTokenValueIndex(tokens, predicate, start) {
        if (start === void 0) { start = 0; }
        for (var i = start; i < tokens.length; i++) {
            if (getTokenType(tokens[i]) === TokenTypes.LiteralString) {
                continue;
            }
            if (getTokenValue(tokens[i]) === '(') {
                i = skipInnerBrackets(tokens, i, '(', ')');
            }
            else if (getTokenValue(tokens[i]) === '[') {
                i = skipInnerBrackets(tokens, i, '[', ']');
            }
            else if (getTokenValue(tokens[i]) === '{') {
                i = skipInnerBrackets(tokens, i, '{', '}');
            }
            else if (predicate(getTokenValue(tokens[i]))) {
                return i;
            }
        }
        return -1;
    }
    function findChainingCallTokensIndexes(tokens) {
        var opIndexes = [];
        for (var i = 0; i < tokens.length; i++) {
            var tValue = getTokenValue(tokens[i]);
            var tType = getTokenType(tokens[i]);
            if (tType === TokenTypes.LiteralString) {
                continue;
            }
            if (tValue === '.') {
                opIndexes.push(i);
            }
            else if (tValue === '(') {
                i = skipInnerBrackets(tokens, i, '(', ')');
            }
            else if (tValue === '[' && i === 0) {
                i = skipInnerBrackets(tokens, i, '[', ']');
            }
            else if (tValue === '[' && i !== 0) {
                opIndexes.push(i);
                i = skipInnerBrackets(tokens, i, '[', ']');
            }
            else if (tValue === '{') {
                i = skipInnerBrackets(tokens, i, '{', '}');
            }
        }
        return opIndexes;
    }
    function findTokenValueIndexes(tokens, predicate) {
        var opIndexes = [];
        for (var i = 0; i < tokens.length; i++) {
            var tValue = getTokenValue(tokens[i]);
            var tType = getTokenType(tokens[i]);
            if (tType === TokenTypes.LiteralString) {
                continue;
            }
            if (tValue === '(') {
                i = skipInnerBrackets(tokens, i, '(', ')');
            }
            else if (tValue === '[') {
                i = skipInnerBrackets(tokens, i, '[', ']');
            }
            else if (tValue === '{') {
                i = skipInnerBrackets(tokens, i, '{', '}');
            }
            else if (predicate(tValue)) {
                opIndexes.push(i);
            }
        }
        return opIndexes;
    }
    function findOperators(tokens, operationType) {
        if (operationType === void 0) { operationType = null; }
        return !operationType
            ? findTokenValueIndexes(tokens, function (value) { return OperatorsMap.has(value); })
            : findTokenValueIndexes(tokens, function (value) { return OperatorsMap.get(value) === operationType; });
    }
    function skipInnerBrackets(tokens, i, openChar, closeChar) {
        var innerBrackets = 0;
        while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {
            if (i + 1 >= tokens.length) {
                throw new Error("Closing '".concat(closeChar, "' is missing"));
            }
            var tokenValue = getTokenValue(tokens[i]);
            if (tokenValue === openChar) {
                innerBrackets++;
            }
            if (tokenValue === closeChar) {
                innerBrackets--;
            }
        }
        return i;
    }

    var AstNode = /** @class */ (function () {
        function AstNode(type) {
            this.type = type;
            this.loc = undefined;
        }
        return AstNode;
    }());
    var AssignNode = /** @class */ (function (_super) {
        __extends(AssignNode, _super);
        function AssignNode(target, source, loc) {
            var _this = _super.call(this, 'assign') || this;
            _this.target = target;
            _this.source = source;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return AssignNode;
    }(AstNode));
    var ConstNode = /** @class */ (function (_super) {
        __extends(ConstNode, _super);
        function ConstNode(token) {
            var _this = _super.call(this, 'const') || this;
            _this.value = getTokenValue(token);
            _this.loc = getTokenLoc(token);
            return _this;
        }
        return ConstNode;
    }(AstNode));
    var CommentNode = /** @class */ (function (_super) {
        __extends(CommentNode, _super);
        function CommentNode(comment, loc) {
            var _this = _super.call(this, 'comment') || this;
            _this.comment = comment;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return CommentNode;
    }(AstNode));
    var ReturnNode = /** @class */ (function (_super) {
        __extends(ReturnNode, _super);
        function ReturnNode(returnValue, loc) {
            if (returnValue === void 0) { returnValue = undefined; }
            var _this = _super.call(this, 'return') || this;
            _this.returnValue = returnValue;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return ReturnNode;
    }(AstNode));
    var RaiseNode = /** @class */ (function (_super) {
        __extends(RaiseNode, _super);
        function RaiseNode(errorName, errorMessageAst, loc) {
            var _this = _super.call(this, 'raise') || this;
            _this.errorName = errorName;
            _this.errorMessageAst = errorMessageAst;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return RaiseNode;
    }(AstNode));
    var ContinueNode = /** @class */ (function (_super) {
        __extends(ContinueNode, _super);
        function ContinueNode() {
            return _super.call(this, 'continue') || this;
        }
        return ContinueNode;
    }(AstNode));
    var BreakNode = /** @class */ (function (_super) {
        __extends(BreakNode, _super);
        function BreakNode() {
            return _super.call(this, 'break') || this;
        }
        return BreakNode;
    }(AstNode));
    /** @class */ ((function (_super) {
        __extends(SetSingleVarNode, _super);
        function SetSingleVarNode(token) {
            var _this = _super.call(this, 'setSingleVar') || this;
            _this.name = token[0];
            _this.loc = getTokenLoc(token);
            return _this;
        }
        return SetSingleVarNode;
    })(AstNode));
    var FunctionCallNode = /** @class */ (function (_super) {
        __extends(FunctionCallNode, _super);
        function FunctionCallNode(name, paramNodes, loc) {
            var _this = _super.call(this, 'funcCall') || this;
            _this.name = name;
            _this.paramNodes = paramNodes;
            _this.loc = loc;
            _this.nullCoelsing = undefined;
            _this.loc = loc;
            return _this;
        }
        return FunctionCallNode;
    }(AstNode));
    var FunctionDefNode = /** @class */ (function (_super) {
        __extends(FunctionDefNode, _super);
        function FunctionDefNode(funcAst, params, isAsync, loc) {
            var _this = _super.call(this, 'funcDef') || this;
            _this.funcAst = funcAst;
            _this.params = params;
            _this.isAsync = isAsync;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return FunctionDefNode;
    }(AstNode));
    var ArrowFuncDefNode = /** @class */ (function (_super) {
        __extends(ArrowFuncDefNode, _super);
        function ArrowFuncDefNode(funcAst, params, loc) {
            var _this = _super.call(this, 'arrowFuncDef') || this;
            _this.funcAst = funcAst;
            _this.params = params;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return ArrowFuncDefNode;
    }(AstNode));
    var ElifNode = /** @class */ (function (_super) {
        __extends(ElifNode, _super);
        function ElifNode(conditionNode, elifBody, loc) {
            var _this = _super.call(this, 'elif') || this;
            _this.conditionNode = conditionNode;
            _this.elifBody = elifBody;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return ElifNode;
    }(AstNode));
    var IfNode = /** @class */ (function (_super) {
        __extends(IfNode, _super);
        function IfNode(conditionNode, ifBody, elifs, elseBody, loc) {
            if (elifs === void 0) { elifs = undefined; }
            if (elseBody === void 0) { elseBody = undefined; }
            var _this = _super.call(this, 'if') || this;
            _this.conditionNode = conditionNode;
            _this.ifBody = ifBody;
            _this.elifs = elifs;
            _this.elseBody = elseBody;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return IfNode;
    }(AstNode));
    var TryExceptNode = /** @class */ (function (_super) {
        __extends(TryExceptNode, _super);
        function TryExceptNode(tryBody, exepts, elseBody, finallyBody, loc) {
            var _this = _super.call(this, 'tryExcept') || this;
            _this.tryBody = tryBody;
            _this.exepts = exepts;
            _this.elseBody = elseBody;
            _this.finallyBody = finallyBody;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return TryExceptNode;
    }(AstNode));
    var ForNode = /** @class */ (function (_super) {
        __extends(ForNode, _super);
        function ForNode(sourceArray, itemVarName, body, loc) {
            var _this = _super.call(this, 'for') || this;
            _this.sourceArray = sourceArray;
            _this.itemVarName = itemVarName;
            _this.body = body;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return ForNode;
    }(AstNode));
    var WhileNode = /** @class */ (function (_super) {
        __extends(WhileNode, _super);
        function WhileNode(condition, body, loc) {
            var _this = _super.call(this, 'while') || this;
            _this.condition = condition;
            _this.body = body;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return WhileNode;
    }(AstNode));
    var ImportNode = /** @class */ (function (_super) {
        __extends(ImportNode, _super);
        function ImportNode(module, body, parts, loc) {
            if (parts === void 0) { parts = undefined; }
            var _this = _super.call(this, 'import') || this;
            _this.module = module;
            _this.body = body;
            _this.parts = parts;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return ImportNode;
    }(AstNode));
    var GetSingleVarNode = /** @class */ (function (_super) {
        __extends(GetSingleVarNode, _super);
        function GetSingleVarNode(token, nullCoelsing) {
            if (nullCoelsing === void 0) { nullCoelsing = undefined; }
            var _this = _super.call(this, 'getSingleVar') || this;
            _this.nullCoelsing = undefined;
            _this.name = token[0];
            _this.nullCoelsing = nullCoelsing;
            _this.loc = getTokenLoc(token);
            return _this;
        }
        return GetSingleVarNode;
    }(AstNode));
    var ChainingCallsNode = /** @class */ (function (_super) {
        __extends(ChainingCallsNode, _super);
        function ChainingCallsNode(innerNodes, loc) {
            var _this = _super.call(this, 'chainingCalls') || this;
            _this.innerNodes = innerNodes;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return ChainingCallsNode;
    }(AstNode));
    var CreateObjectNode = /** @class */ (function (_super) {
        __extends(CreateObjectNode, _super);
        function CreateObjectNode(props, loc) {
            var _this = _super.call(this, 'createObject') || this;
            _this.props = props;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return CreateObjectNode;
    }(AstNode));
    var CreateArrayNode = /** @class */ (function (_super) {
        __extends(CreateArrayNode, _super);
        function CreateArrayNode(items, loc) {
            var _this = _super.call(this, 'createArray') || this;
            _this.items = items;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return CreateArrayNode;
    }(AstNode));
    var ChainingObjectAccessNode = /** @class */ (function (_super) {
        __extends(ChainingObjectAccessNode, _super);
        function ChainingObjectAccessNode(indexerBody, nullCoelsing, loc) {
            if (nullCoelsing === void 0) { nullCoelsing = undefined; }
            var _this = _super.call(this, 'chainingObjectAccess') || this;
            _this.indexerBody = indexerBody;
            _this.nullCoelsing = nullCoelsing;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return ChainingObjectAccessNode;
    }(AstNode));
    var LogicalOpNode = /** @class */ (function (_super) {
        __extends(LogicalOpNode, _super);
        function LogicalOpNode(items, loc) {
            var _this = _super.call(this, 'logicalOp') || this;
            _this.items = items;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return LogicalOpNode;
    }(AstNode));
    var BinOpNode = /** @class */ (function (_super) {
        __extends(BinOpNode, _super);
        function BinOpNode(left, op, right, loc) {
            var _this = _super.call(this, 'binOp') || this;
            _this.left = left;
            _this.op = op;
            _this.right = right;
            _this.loc = loc;
            _this.loc = loc;
            return _this;
        }
        return BinOpNode;
    }(AstNode));

    function cloneContext(context) {
        return {
            moduleName: context.moduleName,
            blockScope: context.blockScope.clone(),
            // this instance should never change. Otherwise cancel won't work
            cancellationToken: context.cancellationToken
        };
    }
    var Scope = /** @class */ (function () {
        function Scope(initialScope) {
            this.scope = {};
            this.scope = __assign({}, initialScope);
        }
        Scope.prototype.getScope = function () {
            return this.scope;
        };
        Scope.prototype.clone = function () {
            return new Scope(this.scope);
        };
        Scope.prototype.set = function (key, value) {
            this.scope[key] = value;
        };
        Scope.prototype.get = function (key) {
            return this.scope[key];
        };
        return Scope;
    }());

    var Evaluator = /** @class */ (function () {
        function Evaluator() {
        }
        Evaluator.prototype.evalBlock = function (ast, blockContext) {
            var _this = this;
            var lastResult = null;
            var _loop_1 = function (node) {
                var funcDef = node;
                // a child scope needs to be created here
                var newScope = blockContext.blockScope;
                newScope.set(funcDef.funcAst.name, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return _this.jspyFuncInvoker.apply(_this, __spreadArray([funcDef, blockContext], args, false));
                });
            };
            for (var _i = 0, _a = (ast === null || ast === void 0 ? void 0 : ast.funcs) || []; _i < _a.length; _i++) {
                var node = _a[_i];
                _loop_1(node);
            }
            for (var i = 0; i < ast.body.length; i++) {
                var node = ast.body[i];
                if (blockContext.cancellationToken.cancel) {
                    var loc = node.loc || [];
                    if (!blockContext.cancellationToken.message) {
                        blockContext.cancellationToken.message = "Cancelled. ".concat(blockContext.moduleName, ": ").concat(loc[0], ", ").concat(loc[1]);
                    }
                    return blockContext.cancellationToken.message;
                }
                if (node.type === 'comment') {
                    continue;
                }
                if (node.type === 'import') {
                    // we can't use it here, because loader has to be promise
                    throw new Error("Import is not support with 'eval'. Use method 'evalAsync' instead");
                }
                try {
                    lastResult = this.evalNode(node, blockContext);
                    if (blockContext.returnCalled) {
                        var res = blockContext.returnObject;
                        // stop processing return
                        if (ast.type == 'func' || ast.type == 'module') {
                            blockContext.returnCalled = false;
                            blockContext.returnObject = null;
                        }
                        return res;
                    }
                    if (blockContext.continueCalled) {
                        break;
                    }
                    if (blockContext.breakCalled) {
                        break;
                    }
                }
                catch (err) {
                    var loc = node.loc ? node.loc : [0, 0];
                    if (err instanceof JspyError) {
                        throw err;
                    }
                    else if (err instanceof JspyEvalError) {
                        throw err;
                    }
                    else {
                        throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], 
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        err.message || err);
                    }
                }
            }
            return lastResult;
        };
        Evaluator.prototype.jspyFuncInvoker = function (funcDef, context) {
            var _a;
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var ast = Object.assign({}, funcDef.funcAst);
            ast.type = 'func';
            var blockContext = cloneContext(context);
            // set parameters into new scope, based incomming arguments
            for (var i = 0; i < ((_a = funcDef.params) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
                var argValue = (args === null || args === void 0 ? void 0 : args.length) > i ? args[i] : null;
                blockContext.blockScope.set(funcDef.params[i], argValue);
            }
            return this.evalBlock(ast, blockContext);
        };
        Evaluator.prototype.invokeFunction = function (func, fps, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        loc) {
            return func.apply(void 0, fps);
        };
        Evaluator.prototype.evalNode = function (node, blockContext) {
            var _this = this;
            var _a, _b, _c, _d, _e, _f, _g;
            if (node.type === 'import') {
                // skip this for now. As modules are implemented externally
                return null;
            }
            if (node.type === 'comment') {
                return null;
            }
            if (node.type === 'if') {
                var ifNode = node;
                var doElse = true;
                if (this.evalNode(ifNode.conditionNode, blockContext)) {
                    this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody }, blockContext);
                    doElse = false;
                }
                else if ((_a = ifNode.elifs) === null || _a === void 0 ? void 0 : _a.length) {
                    for (var i = 0; i < ifNode.elifs.length; i++) {
                        var elIfNode = ifNode.elifs[i];
                        if (this.evalNode(elIfNode.conditionNode, blockContext)) {
                            this.evalBlock({ name: blockContext.moduleName, type: 'if', body: elIfNode.elifBody }, blockContext);
                            doElse = false;
                            break;
                        }
                    }
                }
                if (doElse && ifNode.elseBody) {
                    this.evalBlock({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody }, blockContext);
                }
                return;
            }
            if (node.type === 'raise') {
                var raiseNode = node;
                var errorMessage = this.evalNode(raiseNode.errorMessageAst, blockContext);
                var err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, errorMessage);
                throw err;
            }
            if (node.type === 'tryExcept') {
                var tryNode = node;
                try {
                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody }, blockContext);
                    if (((_b = tryNode.elseBody) === null || _b === void 0 ? void 0 : _b.length) || 0 > 0) {
                        this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody }, blockContext);
                    }
                }
                catch (err) {
                    var name_1 = err instanceof JspyError ? err.name : typeof err;
                    var message = err instanceof JspyError
                        ? err.message
                        : // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            (_c = err === null || err === void 0 ? void 0 : err.message) !== null && _c !== void 0 ? _c : String(err);
                    var moduleName = err instanceof JspyError ? err.module : 0;
                    var line = err instanceof JspyError ? err.line : 0;
                    var column = err instanceof JspyError ? err.column : 0;
                    var firstExept = tryNode.exepts[0];
                    var catchBody = firstExept.body;
                    var ctx = blockContext; // cloneContext(blockContext);
                    ctx.blockScope.set(((_d = firstExept.error) === null || _d === void 0 ? void 0 : _d.alias) || 'error', {
                        name: name_1,
                        message: message,
                        line: line,
                        column: column,
                        moduleName: moduleName
                    });
                    this.evalBlock({ name: blockContext.moduleName, type: 'trycatch', body: catchBody }, ctx);
                    ctx.blockScope.set(((_e = firstExept.error) === null || _e === void 0 ? void 0 : _e.alias) || 'error', null);
                }
                finally {
                    if (((_f = tryNode.finallyBody) === null || _f === void 0 ? void 0 : _f.length) || 0 > 0) {
                        this.evalBlock({
                            name: blockContext.moduleName,
                            type: 'trycatch',
                            body: tryNode.finallyBody
                        }, blockContext);
                    }
                }
                return;
            }
            if (node.type === 'return') {
                var returnNode = node;
                blockContext.returnCalled = true;
                blockContext.returnObject = returnNode.returnValue
                    ? this.evalNode(returnNode.returnValue, blockContext)
                    : null;
                return blockContext.returnObject;
            }
            if (node.type === 'continue') {
                blockContext.continueCalled = true;
                return;
            }
            if (node.type === 'break') {
                blockContext.breakCalled = true;
                return;
            }
            if (node.type === 'for') {
                var forNode = node;
                var array = this.evalNode(forNode.sourceArray, blockContext);
                for (var i = 0; i < array.length; i++) {
                    var item = array[i];
                    blockContext.blockScope.set(forNode.itemVarName, item);
                    this.evalBlock({ name: blockContext.moduleName, type: 'for', body: forNode.body }, blockContext);
                    if (blockContext.continueCalled) {
                        blockContext.continueCalled = false;
                    }
                    if (blockContext.breakCalled) {
                        break;
                    }
                }
                if (blockContext.breakCalled) {
                    blockContext.breakCalled = false;
                }
                return;
            }
            if (node.type === 'while') {
                var whileNode = node;
                while (this.evalNode(whileNode.condition, blockContext)) {
                    this.evalBlock({ name: blockContext.moduleName, type: 'while', body: whileNode.body }, blockContext);
                    if (blockContext.continueCalled) {
                        blockContext.continueCalled = false;
                    }
                    if (blockContext.breakCalled) {
                        break;
                    }
                }
                if (blockContext.breakCalled) {
                    blockContext.breakCalled = false;
                }
                return;
            }
            if (node.type === 'const') {
                return node.value;
            }
            if (node.type === 'getSingleVar') {
                var name_2 = node.name;
                var value = blockContext.blockScope.get(node.name);
                if (value === undefined) {
                    if (name_2.charAt(name_2.length - 1) === ';') {
                        throw new Error("Unexpected ';' in the end.");
                    }
                    else {
                        throw new Error("Variable '".concat(name_2, "' is not defined."));
                    }
                }
                return value;
            }
            if (node.type === 'binOp') {
                var binOpNode = node;
                var left = this.evalNode(binOpNode.left, blockContext);
                var right = this.evalNode(binOpNode.right, blockContext);
                var func = OperationFuncs.get(binOpNode.op);
                if (typeof func === 'function')
                    return func(left, right);
                else
                    throw new Error('Unknown binary oprastion');
            }
            if (node.type === 'logicalOp') {
                var logicalGroups = node;
                var ind = 0;
                var gResult = true;
                while (ind < logicalGroups.items.length) {
                    var eg = logicalGroups.items[ind++];
                    gResult = this.evalNode(eg.node, blockContext);
                    if (eg.op === 'and' && !gResult) {
                        return false;
                    }
                    if (eg.op === 'or' && gResult) {
                        return gResult;
                    }
                }
                return gResult;
            }
            if (node.type === 'arrowFuncDef') {
                var arrowFuncDef_1 = node;
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return _this.jspyFuncInvoker.apply(_this, __spreadArray([arrowFuncDef_1, blockContext], args, false));
                };
            }
            if (node.type === 'funcCall') {
                var funcCallNode = node;
                var func = blockContext.blockScope.get(funcCallNode.name);
                if (typeof func !== 'function') {
                    throw Error("'".concat(funcCallNode.name, "' is not a function or not defined."));
                }
                var pms = ((_g = funcCallNode.paramNodes) === null || _g === void 0 ? void 0 : _g.map(function (n) { return _this.evalNode(n, blockContext); })) || [];
                return this.invokeFunction(func, pms, {
                    moduleName: blockContext.moduleName,
                    line: funcCallNode.loc[0],
                    column: funcCallNode.loc[1]
                });
            }
            if (node.type === 'assign') {
                var assignNode = node;
                if (assignNode.target.type === 'getSingleVar') {
                    var node_1 = assignNode.target;
                    blockContext.blockScope.set(node_1.name, this.evalNode(assignNode.source, blockContext));
                }
                else if (assignNode.target.type === 'chainingCalls') {
                    var targetNode = assignNode.target;
                    // create a node for all but last property token
                    // potentially it can go to parser
                    var targetObjectNode = new ChainingCallsNode(targetNode.innerNodes.slice(0, targetNode.innerNodes.length - 1), targetNode.loc);
                    var targetObject = this.evalNode(targetObjectNode, blockContext);
                    var lastInnerNode = targetNode.innerNodes[targetNode.innerNodes.length - 1];
                    var lastPropertyName = '';
                    if (lastInnerNode.type === 'getSingleVar') {
                        lastPropertyName = lastInnerNode.name;
                    }
                    else if (lastInnerNode.type === 'chainingObjectAccess') {
                        lastPropertyName = this.evalNode(lastInnerNode.indexerBody, blockContext);
                    }
                    else {
                        throw Error('Not implemented Assign operation with chaining calls');
                    }
                    targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);
                }
                return null;
            }
            if (node.type === 'chainingCalls') {
                return this.resolveChainingCallsNode(node, blockContext);
            }
            if (node.type === 'createObject') {
                var createObjectNode = node;
                var obj = {};
                for (var _i = 0, _h = createObjectNode.props; _i < _h.length; _i++) {
                    var p = _h[_i];
                    obj[this.evalNode(p.name, blockContext)] = this.evalNode(p.value, blockContext);
                }
                return obj;
            }
            if (node.type === 'createArray') {
                var arrayNode = node;
                var res = [];
                for (var _j = 0, _k = arrayNode.items; _j < _k.length; _j++) {
                    var item = _k[_j];
                    res.push(this.evalNode(item, blockContext));
                }
                return res;
            }
        };
        Evaluator.prototype.resolveChainingCallsNode = function (chNode, blockContext) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var startObject = this.evalNode(chNode.innerNodes[0], blockContext);
            for (var i = 1; i < chNode.innerNodes.length; i++) {
                var nestedProp = chNode.innerNodes[i];
                if (chNode.innerNodes[i - 1].nullCoelsing && !startObject) {
                    startObject = {};
                }
                if (nestedProp.type === 'getSingleVar') {
                    startObject = startObject[nestedProp.name];
                }
                else if (nestedProp.type === 'chainingObjectAccess') {
                    var node = nestedProp;
                    // startObject = startObject[node.] as unknown;
                    startObject = startObject[this.evalNode(node.indexerBody, blockContext)];
                }
                else if (nestedProp.type === 'funcCall') {
                    var funcCallNode = nestedProp;
                    var func = startObject[funcCallNode.name];
                    if ((func === undefined || func === null) &&
                        chNode.innerNodes[i - 1].nullCoelsing) {
                        startObject = null;
                        continue;
                    }
                    if (typeof func !== 'function') {
                        throw Error("'".concat(funcCallNode.name, "' is not a function or not defined."));
                    }
                    var pms = [];
                    for (var _i = 0, _a = funcCallNode.paramNodes || []; _i < _a.length; _i++) {
                        var p = _a[_i];
                        pms.push(this.evalNode(p, blockContext));
                    }
                    startObject = this.invokeFunction(func.bind(startObject), pms, {
                        moduleName: blockContext.moduleName,
                        line: funcCallNode.loc[0],
                        column: funcCallNode.loc[0]
                    });
                }
                else {
                    throw Error("Can't resolve chainingCalls node");
                }
            }
            return startObject === undefined ? null : startObject;
        };
        return Evaluator;
    }());

    /**
     * This is copy/paste from Evaluator.
     * Sadly, we have to copy code around to support both async and non async methods.
     * So, any changes to this method, should be replicated in the evaluator.ts
     */
    var EvaluatorAsync = /** @class */ (function () {
        function EvaluatorAsync() {
            this.moduleParser = function () {
                return Promise.reject('Module parser is not registered!');
            };
            this.jsonFileLoader = function () { return Promise.reject('{}'); };
        }
        EvaluatorAsync.prototype.registerModuleParser = function (moduleParser) {
            this.moduleParser = moduleParser;
            return this;
        };
        EvaluatorAsync.prototype.registerJsonFileLoader = function (jsonFileLoader) {
            this.jsonFileLoader = jsonFileLoader;
            return this;
        };
        EvaluatorAsync.prototype.registerBlockContextFactory = function (blockContextFactory) {
            this.blockContextFactory = blockContextFactory;
            return this;
        };
        EvaluatorAsync.prototype.evalBlockAsync = function (ast, blockContext) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var lastResult, _loop_1, _i, _c, node, i, node, loc, importNode, iType, jsonValue, _d, _e, moduleAst, moduleBlockContext, scope, res, err_1, loc;
                var _this = this;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            lastResult = null;
                            _loop_1 = function (node) {
                                var funcDef = node;
                                // a child scope needs to be created here
                                var newScope = blockContext.blockScope;
                                var invoker = funcDef.isAsync
                                    ? function () {
                                        var args = [];
                                        for (var _i = 0; _i < arguments.length; _i++) {
                                            args[_i] = arguments[_i];
                                        }
                                        return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, this.jspyFuncInvokerAsync.apply(this, __spreadArray([funcDef, blockContext], args, false))];
                                                case 1: return [2 /*return*/, _a.sent()];
                                            }
                                        }); });
                                    }
                                    : function () {
                                        var _a;
                                        var args = [];
                                        for (var _i = 0; _i < arguments.length; _i++) {
                                            args[_i] = arguments[_i];
                                        }
                                        return (_a = new Evaluator()).jspyFuncInvoker.apply(_a, __spreadArray([funcDef, blockContext], args, false));
                                    };
                                newScope.set(funcDef.funcAst.name, invoker);
                            };
                            for (_i = 0, _c = (ast === null || ast === void 0 ? void 0 : ast.funcs) || []; _i < _c.length; _i++) {
                                node = _c[_i];
                                _loop_1(node);
                            }
                            i = 0;
                            _f.label = 1;
                        case 1:
                            if (!(i < ast.body.length)) return [3 /*break*/, 11];
                            node = ast.body[i];
                            if (blockContext.cancellationToken.cancel) {
                                loc = node.loc || [];
                                if (!blockContext.cancellationToken.message) {
                                    blockContext.cancellationToken.message = "Cancelled. ".concat(blockContext.moduleName, ": ").concat(loc[0], ", ").concat(loc[1]);
                                }
                                return [2 /*return*/, blockContext.cancellationToken.message];
                            }
                            if (node.type === 'comment') {
                                return [3 /*break*/, 10];
                            }
                            if (!(node.type === 'import')) return [3 /*break*/, 7];
                            importNode = node;
                            iType = getImportType(importNode.module.name);
                            if (!(iType === 'json')) return [3 /*break*/, 3];
                            _e = (_d = JSON).parse;
                            return [4 /*yield*/, this.jsonFileLoader(importNode.module.name)];
                        case 2:
                            jsonValue = _e.apply(_d, [_f.sent()]);
                            blockContext.blockScope.set(importNode.module.alias || this.defaultModuleName(importNode.module.name), jsonValue);
                            return [3 /*break*/, 10];
                        case 3:
                            if (iType !== 'jspyModule') {
                                // it is not JSPY import. It is JS and should be handled externally
                                return [3 /*break*/, 10];
                            }
                            _f.label = 4;
                        case 4:
                            if (typeof this.blockContextFactory !== 'function') {
                                throw new Error('blockContextFactory is not initialized');
                            }
                            return [4 /*yield*/, this.moduleParser(importNode.module.name)];
                        case 5:
                            moduleAst = _f.sent();
                            moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);
                            return [4 /*yield*/, this.evalBlockAsync(moduleAst, moduleBlockContext)];
                        case 6:
                            _f.sent();
                            scope = blockContext.blockScope.getScope();
                            if (!((_a = importNode.parts) === null || _a === void 0 ? void 0 : _a.length)) {
                                // if no parts, then we need to assign to a separate object
                                scope = {};
                                blockContext.blockScope.set(importNode.module.alias || this.defaultModuleName(importNode.module.name), scope);
                            }
                            this.assignFunctionsToScope(scope, moduleBlockContext, moduleAst, (_b = importNode.parts) === null || _b === void 0 ? void 0 : _b.map(function (p) { return p.name; }));
                            return [3 /*break*/, 10];
                        case 7:
                            _f.trys.push([7, 9, , 10]);
                            return [4 /*yield*/, this.evalNodeAsync(node, blockContext)];
                        case 8:
                            lastResult = _f.sent();
                            if (blockContext.returnCalled) {
                                res = blockContext.returnObject;
                                // stop processing return
                                if (ast.type == 'func' || ast.type == 'module') {
                                    blockContext.returnCalled = false;
                                    blockContext.returnObject = null;
                                }
                                return [2 /*return*/, res];
                            }
                            if (blockContext.continueCalled) {
                                return [3 /*break*/, 11];
                            }
                            if (blockContext.breakCalled) {
                                return [3 /*break*/, 11];
                            }
                            return [3 /*break*/, 10];
                        case 9:
                            err_1 = _f.sent();
                            loc = node.loc ? node.loc : [0, 0];
                            if (err_1 instanceof JspyError) {
                                throw err_1;
                            }
                            else if (err_1 instanceof JspyEvalError) {
                                throw err_1;
                            }
                            else {
                                throw new JspyEvalError(blockContext.moduleName, loc[0], loc[1], 
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                err_1.message || err_1);
                            }
                        case 10:
                            i++;
                            return [3 /*break*/, 1];
                        case 11: return [2 /*return*/, lastResult];
                    }
                });
            });
        };
        EvaluatorAsync.prototype.assignFunctionsToScope = function (scope, moduleBlockContext, moduleAst, parts) {
            var _this = this;
            var funcs = moduleAst.funcs.filter(function (f) { var _a; return !parts || parts.indexOf((_a = f.funcAst) === null || _a === void 0 ? void 0 : _a.name) >= 0; });
            var _loop_2 = function (i) {
                var funcDef = funcs[i];
                var invoker = funcDef.isAsync
                    ? function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.jspyFuncInvokerAsync.apply(this, __spreadArray([funcDef, moduleBlockContext], args, false))];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); });
                    }
                    : function () {
                        var _a;
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return (_a = new Evaluator()).jspyFuncInvoker.apply(_a, __spreadArray([funcDef, moduleBlockContext], args, false));
                    };
                scope[funcDef.funcAst.name] = invoker;
            };
            for (var i = 0; i < funcs.length; i++) {
                _loop_2(i);
            }
        };
        EvaluatorAsync.prototype.defaultModuleName = function (name) {
            return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'));
        };
        EvaluatorAsync.prototype.jspyFuncInvokerAsync = function (funcDef, context) {
            var _a;
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var ast, blockContext, i, argValue;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            ast = Object.assign({}, funcDef.funcAst);
                            ast.type = 'func';
                            blockContext = cloneContext(context);
                            // set parameters into new scope, based incomming arguments
                            for (i = 0; i < ((_a = funcDef.params) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
                                argValue = (args === null || args === void 0 ? void 0 : args.length) > i ? args[i] : null;
                                blockContext.blockScope.set(funcDef.params[i], argValue);
                            }
                            return [4 /*yield*/, this.evalBlockAsync(ast, blockContext)];
                        case 1: return [2 /*return*/, _b.sent()];
                    }
                });
            });
        };
        EvaluatorAsync.prototype.invokeFunctionAsync = function (func, fps, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        loc) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, func.apply(void 0, fps)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        EvaluatorAsync.prototype.evalNodeAsync = function (node, blockContext) {
            var _a, _b, _c, _d, _e, _f;
            return __awaiter(this, void 0, void 0, function () {
                var ifNode, doElse, i, elIfNode, raiseNode, errorMessage, err, tryNode, err_2, name_1, message, moduleName, line, column, firstExept, catchBody, ctx, returnNode, _g, _h, forNode, array, i, item, whileNode, name_2, value, binOpNode, left, right, func, logicalGroups, ind, gResult, eg, arrowFuncDef_1, funcCallNode, func, pms, _i, _j, p, _k, _l, assignNode, node_1, _m, _o, _p, targetNode, targetObjectNode, targetObject, lastInnerNode, lastPropertyName, _q, _r, createObjectNode, obj, _s, _t, p, _u, _v, arrayNode, res, _w, _x, item, _y, _z;
                return __generator(this, function (_0) {
                    switch (_0.label) {
                        case 0:
                            if (node.type === 'import') {
                                throw new Error('Import should be defined at the start');
                            }
                            if (node.type === 'comment') {
                                return [2 /*return*/, null];
                            }
                            if (!(node.type === 'if')) return [3 /*break*/, 11];
                            ifNode = node;
                            doElse = true;
                            return [4 /*yield*/, this.evalNodeAsync(ifNode.conditionNode, blockContext)];
                        case 1:
                            if (!_0.sent()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.ifBody }, blockContext)];
                        case 2:
                            _0.sent();
                            doElse = false;
                            return [3 /*break*/, 8];
                        case 3:
                            if (!((_a = ifNode.elifs) === null || _a === void 0 ? void 0 : _a.length)) return [3 /*break*/, 8];
                            i = 0;
                            _0.label = 4;
                        case 4:
                            if (!(i < ifNode.elifs.length)) return [3 /*break*/, 8];
                            elIfNode = ifNode.elifs[i];
                            return [4 /*yield*/, this.evalNodeAsync(elIfNode.conditionNode, blockContext)];
                        case 5:
                            if (!_0.sent()) return [3 /*break*/, 7];
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: elIfNode.elifBody }, blockContext)];
                        case 6:
                            _0.sent();
                            doElse = false;
                            return [3 /*break*/, 8];
                        case 7:
                            i++;
                            return [3 /*break*/, 4];
                        case 8:
                            if (!(doElse && ifNode.elseBody)) return [3 /*break*/, 10];
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'if', body: ifNode.elseBody }, blockContext)];
                        case 9:
                            _0.sent();
                            _0.label = 10;
                        case 10: return [2 /*return*/];
                        case 11:
                            if (!(node.type === 'raise')) return [3 /*break*/, 13];
                            raiseNode = node;
                            return [4 /*yield*/, this.evalNodeAsync(raiseNode.errorMessageAst, blockContext)];
                        case 12:
                            errorMessage = (_0.sent());
                            err = new JspyError(blockContext.moduleName, raiseNode.loc[0], raiseNode.loc[1], raiseNode.errorName, errorMessage);
                            throw err;
                        case 13:
                            if (!(node.type === 'tryExcept')) return [3 /*break*/, 24];
                            tryNode = node;
                            _0.label = 14;
                        case 14:
                            _0.trys.push([14, 18, 20, 23]);
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody }, blockContext)];
                        case 15:
                            _0.sent();
                            if (!(((_b = tryNode.elseBody) === null || _b === void 0 ? void 0 : _b.length) || 0 > 0)) return [3 /*break*/, 17];
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody }, blockContext)];
                        case 16:
                            _0.sent();
                            _0.label = 17;
                        case 17: return [3 /*break*/, 23];
                        case 18:
                            err_2 = _0.sent();
                            name_1 = err_2 instanceof JspyError ? err_2.name : typeof err_2;
                            message = err_2 instanceof JspyError
                                ? err_2.message
                                : // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    (_c = err_2 === null || err_2 === void 0 ? void 0 : err_2.message) !== null && _c !== void 0 ? _c : String(err_2);
                            moduleName = err_2 instanceof JspyError ? err_2.module : 0;
                            line = err_2 instanceof JspyError ? err_2.line : 0;
                            column = err_2 instanceof JspyError ? err_2.column : 0;
                            firstExept = tryNode.exepts[0];
                            catchBody = firstExept.body;
                            ctx = blockContext;
                            ctx.blockScope.set(((_d = firstExept.error) === null || _d === void 0 ? void 0 : _d.alias) || 'error', {
                                name: name_1,
                                message: message,
                                line: line,
                                column: column,
                                moduleName: moduleName
                            });
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'trycatch', body: catchBody }, ctx)];
                        case 19:
                            _0.sent();
                            ctx.blockScope.set(((_e = firstExept.error) === null || _e === void 0 ? void 0 : _e.alias) || 'error', null);
                            return [3 /*break*/, 23];
                        case 20:
                            if (!(((_f = tryNode.finallyBody) === null || _f === void 0 ? void 0 : _f.length) || 0 > 0)) return [3 /*break*/, 22];
                            return [4 /*yield*/, this.evalBlockAsync({
                                    name: blockContext.moduleName,
                                    type: 'trycatch',
                                    body: tryNode.finallyBody
                                }, blockContext)];
                        case 21:
                            _0.sent();
                            _0.label = 22;
                        case 22: return [7 /*endfinally*/];
                        case 23: return [2 /*return*/];
                        case 24:
                            if (!(node.type === 'return')) return [3 /*break*/, 28];
                            returnNode = node;
                            blockContext.returnCalled = true;
                            _g = blockContext;
                            if (!returnNode.returnValue) return [3 /*break*/, 26];
                            return [4 /*yield*/, this.evalNodeAsync(returnNode.returnValue, blockContext)];
                        case 25:
                            _h = _0.sent();
                            return [3 /*break*/, 27];
                        case 26:
                            _h = null;
                            _0.label = 27;
                        case 27:
                            _g.returnObject = _h;
                            return [2 /*return*/, blockContext.returnObject];
                        case 28:
                            if (node.type === 'continue') {
                                blockContext.continueCalled = true;
                                return [2 /*return*/];
                            }
                            if (node.type === 'break') {
                                blockContext.breakCalled = true;
                                return [2 /*return*/];
                            }
                            if (!(node.type === 'for')) return [3 /*break*/, 34];
                            forNode = node;
                            return [4 /*yield*/, this.evalNodeAsync(forNode.sourceArray, blockContext)];
                        case 29:
                            array = (_0.sent());
                            i = 0;
                            _0.label = 30;
                        case 30:
                            if (!(i < array.length)) return [3 /*break*/, 33];
                            item = array[i];
                            blockContext.blockScope.set(forNode.itemVarName, item);
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'for', body: forNode.body }, blockContext)];
                        case 31:
                            _0.sent();
                            if (blockContext.continueCalled) {
                                blockContext.continueCalled = false;
                            }
                            if (blockContext.breakCalled) {
                                return [3 /*break*/, 33];
                            }
                            _0.label = 32;
                        case 32:
                            i++;
                            return [3 /*break*/, 30];
                        case 33:
                            if (blockContext.breakCalled) {
                                blockContext.breakCalled = false;
                            }
                            return [2 /*return*/];
                        case 34:
                            if (!(node.type === 'while')) return [3 /*break*/, 39];
                            whileNode = node;
                            _0.label = 35;
                        case 35: return [4 /*yield*/, this.evalNodeAsync(whileNode.condition, blockContext)];
                        case 36:
                            if (!_0.sent()) return [3 /*break*/, 38];
                            return [4 /*yield*/, this.evalBlockAsync({ name: blockContext.moduleName, type: 'while', body: whileNode.body }, blockContext)];
                        case 37:
                            _0.sent();
                            if (blockContext.continueCalled) {
                                blockContext.continueCalled = false;
                            }
                            if (blockContext.breakCalled) {
                                return [3 /*break*/, 38];
                            }
                            return [3 /*break*/, 35];
                        case 38:
                            if (blockContext.breakCalled) {
                                blockContext.breakCalled = false;
                            }
                            return [2 /*return*/];
                        case 39:
                            if (node.type === 'const') {
                                return [2 /*return*/, node.value];
                            }
                            if (node.type === 'getSingleVar') {
                                name_2 = node.name;
                                value = blockContext.blockScope.get(name_2);
                                if (value === undefined) {
                                    if (name_2.charAt(name_2.length - 1) === ';') {
                                        throw new Error("Unexpected ';' in the end.");
                                    }
                                    else {
                                        throw new Error("Variable '".concat(name_2, "' is not defined."));
                                    }
                                }
                                return [2 /*return*/, value];
                            }
                            if (!(node.type === 'binOp')) return [3 /*break*/, 42];
                            binOpNode = node;
                            return [4 /*yield*/, this.evalNodeAsync(binOpNode.left, blockContext)];
                        case 40:
                            left = _0.sent();
                            return [4 /*yield*/, this.evalNodeAsync(binOpNode.right, blockContext)];
                        case 41:
                            right = _0.sent();
                            func = OperationFuncs.get(binOpNode.op);
                            if (typeof func === 'function')
                                return [2 /*return*/, func(left, right)];
                            else
                                throw new Error('Unknown binary oprastion');
                        case 42:
                            if (!(node.type === 'logicalOp')) return [3 /*break*/, 46];
                            logicalGroups = node;
                            ind = 0;
                            gResult = true;
                            _0.label = 43;
                        case 43:
                            if (!(ind < logicalGroups.items.length)) return [3 /*break*/, 45];
                            eg = logicalGroups.items[ind++];
                            return [4 /*yield*/, this.evalNodeAsync(eg.node, blockContext)];
                        case 44:
                            gResult = _0.sent();
                            if (eg.op === 'and' && !gResult) {
                                return [2 /*return*/, false];
                            }
                            if (eg.op === 'or' && gResult) {
                                return [2 /*return*/, gResult];
                            }
                            return [3 /*break*/, 43];
                        case 45: return [2 /*return*/, gResult];
                        case 46:
                            if (node.type === 'arrowFuncDef') {
                                arrowFuncDef_1 = node;
                                return [2 /*return*/, function () {
                                        var _a;
                                        var args = [];
                                        for (var _i = 0; _i < arguments.length; _i++) {
                                            args[_i] = arguments[_i];
                                        }
                                        return (_a = new Evaluator()).jspyFuncInvoker.apply(_a, __spreadArray([arrowFuncDef_1, blockContext], args, false));
                                    }];
                            }
                            if (!(node.type === 'funcCall')) return [3 /*break*/, 52];
                            funcCallNode = node;
                            func = blockContext.blockScope.get(funcCallNode.name);
                            if (typeof func !== 'function') {
                                throw Error("'".concat(funcCallNode.name, "' is not a function or not defined."));
                            }
                            pms = [];
                            _i = 0, _j = funcCallNode.paramNodes || [];
                            _0.label = 47;
                        case 47:
                            if (!(_i < _j.length)) return [3 /*break*/, 50];
                            p = _j[_i];
                            _l = (_k = pms).push;
                            return [4 /*yield*/, this.evalNodeAsync(p, blockContext)];
                        case 48:
                            _l.apply(_k, [_0.sent()]);
                            _0.label = 49;
                        case 49:
                            _i++;
                            return [3 /*break*/, 47];
                        case 50: return [4 /*yield*/, this.invokeFunctionAsync(func, pms, {
                                moduleName: blockContext.moduleName,
                                line: funcCallNode.loc[0],
                                column: funcCallNode.loc[0]
                            })];
                        case 51: return [2 /*return*/, _0.sent()];
                        case 52:
                            if (!(node.type === 'assign')) return [3 /*break*/, 62];
                            assignNode = node;
                            if (!(assignNode.target.type === 'getSingleVar')) return [3 /*break*/, 54];
                            node_1 = assignNode.target;
                            _o = (_m = blockContext.blockScope).set;
                            _p = [node_1.name];
                            return [4 /*yield*/, this.evalNodeAsync(assignNode.source, blockContext)];
                        case 53:
                            _o.apply(_m, _p.concat([_0.sent()]));
                            return [3 /*break*/, 61];
                        case 54:
                            if (!(assignNode.target.type === 'chainingCalls')) return [3 /*break*/, 61];
                            targetNode = assignNode.target;
                            targetObjectNode = new ChainingCallsNode(targetNode.innerNodes.slice(0, targetNode.innerNodes.length - 1), targetNode.loc);
                            return [4 /*yield*/, this.evalNodeAsync(targetObjectNode, blockContext)];
                        case 55:
                            targetObject = (_0.sent());
                            lastInnerNode = targetNode.innerNodes[targetNode.innerNodes.length - 1];
                            lastPropertyName = '';
                            if (!(lastInnerNode.type === 'getSingleVar')) return [3 /*break*/, 56];
                            lastPropertyName = lastInnerNode.name;
                            return [3 /*break*/, 59];
                        case 56:
                            if (!(lastInnerNode.type === 'chainingObjectAccess')) return [3 /*break*/, 58];
                            return [4 /*yield*/, this.evalNodeAsync(lastInnerNode.indexerBody, blockContext)];
                        case 57:
                            lastPropertyName = (_0.sent());
                            return [3 /*break*/, 59];
                        case 58: throw Error('Not implemented Assign operation with chaining calls');
                        case 59:
                            _q = targetObject;
                            _r = lastPropertyName;
                            return [4 /*yield*/, this.evalNodeAsync(assignNode.source, blockContext)];
                        case 60:
                            _q[_r] = _0.sent();
                            _0.label = 61;
                        case 61: return [2 /*return*/, null];
                        case 62:
                            if (!(node.type === 'chainingCalls')) return [3 /*break*/, 64];
                            return [4 /*yield*/, this.resolveChainingCallsNode(node, blockContext)];
                        case 63: return [2 /*return*/, _0.sent()];
                        case 64:
                            if (!(node.type === 'createObject')) return [3 /*break*/, 70];
                            createObjectNode = node;
                            obj = {};
                            _s = 0, _t = createObjectNode.props;
                            _0.label = 65;
                        case 65:
                            if (!(_s < _t.length)) return [3 /*break*/, 69];
                            p = _t[_s];
                            _u = obj;
                            return [4 /*yield*/, this.evalNodeAsync(p.name, blockContext)];
                        case 66:
                            _v = (_0.sent());
                            return [4 /*yield*/, this.evalNodeAsync(p.value, blockContext)];
                        case 67:
                            _u[_v] = _0.sent();
                            _0.label = 68;
                        case 68:
                            _s++;
                            return [3 /*break*/, 65];
                        case 69: return [2 /*return*/, obj];
                        case 70:
                            if (!(node.type === 'createArray')) return [3 /*break*/, 75];
                            arrayNode = node;
                            res = [];
                            _w = 0, _x = arrayNode.items;
                            _0.label = 71;
                        case 71:
                            if (!(_w < _x.length)) return [3 /*break*/, 74];
                            item = _x[_w];
                            _z = (_y = res).push;
                            return [4 /*yield*/, this.evalNodeAsync(item, blockContext)];
                        case 72:
                            _z.apply(_y, [_0.sent()]);
                            _0.label = 73;
                        case 73:
                            _w++;
                            return [3 /*break*/, 71];
                        case 74: return [2 /*return*/, res];
                        case 75: return [2 /*return*/];
                    }
                });
            });
        };
        EvaluatorAsync.prototype.resolveChainingCallsNode = function (chNode, blockContext) {
            return __awaiter(this, void 0, void 0, function () {
                var startObject, i, nestedProp, node, _a, funcCallNode, func, pms, _i, _b, p, _c, _d;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0: return [4 /*yield*/, this.evalNodeAsync(chNode.innerNodes[0], blockContext)];
                        case 1:
                            startObject = (_e.sent());
                            i = 1;
                            _e.label = 2;
                        case 2:
                            if (!(i < chNode.innerNodes.length)) return [3 /*break*/, 13];
                            nestedProp = chNode.innerNodes[i];
                            if (chNode.innerNodes[i - 1].nullCoelsing && !startObject) {
                                startObject = {};
                            }
                            if (!(nestedProp.type === 'getSingleVar')) return [3 /*break*/, 3];
                            startObject = startObject[nestedProp.name];
                            return [3 /*break*/, 12];
                        case 3:
                            if (!(nestedProp.type === 'chainingObjectAccess')) return [3 /*break*/, 5];
                            node = nestedProp;
                            _a = startObject;
                            return [4 /*yield*/, this.evalNodeAsync(node.indexerBody, blockContext)];
                        case 4:
                            // startObject = startObject[node.] as unknown;
                            startObject = _a[(_e.sent())];
                            return [3 /*break*/, 12];
                        case 5:
                            if (!(nestedProp.type === 'funcCall')) return [3 /*break*/, 11];
                            funcCallNode = nestedProp;
                            func = startObject[funcCallNode.name];
                            if ((func === undefined || func === null) &&
                                chNode.innerNodes[i - 1].nullCoelsing) {
                                startObject = null;
                                return [3 /*break*/, 12];
                            }
                            if (typeof func !== 'function') {
                                throw Error("'".concat(funcCallNode.name, "' is not a function or not defined."));
                            }
                            pms = [];
                            _i = 0, _b = funcCallNode.paramNodes || [];
                            _e.label = 6;
                        case 6:
                            if (!(_i < _b.length)) return [3 /*break*/, 9];
                            p = _b[_i];
                            _d = (_c = pms).push;
                            return [4 /*yield*/, this.evalNodeAsync(p, blockContext)];
                        case 7:
                            _d.apply(_c, [_e.sent()]);
                            _e.label = 8;
                        case 8:
                            _i++;
                            return [3 /*break*/, 6];
                        case 9: return [4 /*yield*/, this.invokeFunctionAsync(func.bind(startObject), pms, {
                                moduleName: blockContext.moduleName,
                                line: funcCallNode.loc[0],
                                column: funcCallNode.loc[0]
                            })];
                        case 10:
                            startObject = _e.sent();
                            return [3 /*break*/, 12];
                        case 11: throw Error("Can't resolve chainingCalls node");
                        case 12:
                            i++;
                            return [3 /*break*/, 2];
                        case 13: return [2 /*return*/, startObject === undefined ? null : startObject];
                    }
                });
            });
        };
        return EvaluatorAsync;
    }());

    var INITIAL_SCOPE = {
        jsPython: function () {
            return "JSPython v2.1.10 (c) 2022 FalconSoft Ltd. All rights reserved.";
        },
        dateTime: function (str) {
            if (str === void 0) { str = null; }
            return parseDatetimeOrNull(str) || new Date();
        },
        range: range,
        print: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            console.log.apply(console, args);
            return args.length > 0 ? args[0] : null;
        },
        isNull: function (v, defValue) {
            if (defValue === void 0) { defValue = null; }
            return defValue === null ? v === null : v || defValue;
        },
        isDate: function (d) { return d instanceof Date; },
        isFunction: function (v) { return typeof v === 'function'; },
        isString: function (v) { return typeof v === 'string'; },
        deleteProperty: function (obj, propName) { return delete obj[propName]; },
        Math: Math,
        Object: Object,
        Array: Array,
        JSON: JSON,
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        printExecutionContext: function () { },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        getExecutionContext: function () { return ({}); } // will be overriden at runtime
    };
    function range(start, stop, step) {
        if (stop === void 0) { stop = NaN; }
        if (step === void 0) { step = 1; }
        var arr = [];
        var isStopNaN = isNaN(stop);
        stop = isStopNaN ? start : stop;
        start = isStopNaN ? 0 : start;
        var i = start;
        while (i < stop) {
            arr.push(i);
            i += step;
        }
        return arr;
    }

    var InstructionLine = /** @class */ (function () {
        function InstructionLine() {
            this.tokens = [];
        }
        InstructionLine.prototype.startLine = function () {
            return getStartLine(this.tokens[0]);
        };
        InstructionLine.prototype.startColumn = function () {
            return getStartColumn(this.tokens[0]);
        };
        InstructionLine.prototype.endLine = function () {
            return getEndLine(this.tokens[this.tokens.length - 1]);
        };
        InstructionLine.prototype.endColumn = function () {
            return getEndColumn(this.tokens[this.tokens.length - 1]);
        };
        return InstructionLine;
    }());
    var Parser = /** @class */ (function () {
        function Parser() {
            this._currentToken = null;
            this._moduleName = '';
        }
        /**
         * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code
         * @param tokens tokens
         * @param options parsing options. By default it will exclude comments and include LOC (Line of code)
         */
        Parser.prototype.parse = function (tokens, name, type) {
            var _a;
            if (name === void 0) { name = 'main.jspy'; }
            if (type === void 0) { type = 'module'; }
            this._moduleName = name;
            var ast = { name: name, type: type, funcs: [], body: [] };
            if (!tokens || !tokens.length) {
                return ast;
            }
            try {
                // group all tokens into an Instruction lines.
                var instructions = this.tokensToInstructionLines(tokens, 1);
                // process all instructions
                this.instructionsToNodes(instructions, ast);
            }
            catch (error) {
                var err = error;
                var token = (_a = this._currentToken) !== null && _a !== void 0 ? _a : {};
                throw new JspyParserError(ast.name, getStartLine(token), getStartColumn(token), err.message || String(err));
            }
            return ast;
        };
        Parser.prototype.instructionsToNodes = function (instructions, ast) {
            var _this = this;
            var getBody = function (tokens, startTokenIndex) {
                var instructionLines = _this.tokensToInstructionLines(tokens, getStartLine(tokens[startTokenIndex]));
                var bodyAst = { name: ast.name, body: [], funcs: [] };
                _this.instructionsToNodes(instructionLines, bodyAst);
                return bodyAst.body;
            };
            var findIndexes = function (tkns, operation, result) {
                result.splice(0, result.length);
                findOperators(tkns, operation).forEach(function (r) { return result.push(r); });
                return !!result.length;
            };
            for (var i = 0; i < instructions.length; i++) {
                var instruction = instructions[i];
                // remove comments
                var tt = 0;
                while (tt < instruction.tokens.length) {
                    if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {
                        instruction.tokens.splice(tt, 1);
                    }
                    else {
                        tt++;
                    }
                }
                if (!instruction.tokens.length) {
                    continue;
                }
                var firstToken = instruction.tokens[0];
                var secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;
                this._currentToken = firstToken;
                var logicOpIndexes = [];
                var assignTokenIndexes = [];
                if (getTokenType(firstToken) === TokenTypes.Comment) {
                    ast.body.push(new CommentNode(getTokenValue(firstToken), getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'def' ||
                    (getTokenValue(firstToken) === 'async' && getTokenValue(secondToken) === 'def')) {
                    var isAsync = getTokenValue(firstToken) === 'async';
                    var funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]);
                    var paramsTokens = instruction.tokens.slice(instruction.tokens.findIndex(function (tkns) { return getTokenValue(tkns) === '('; }) + 1, instruction.tokens.findIndex(function (tkns) { return getTokenValue(tkns) === ')'; }));
                    var params = splitTokens(paramsTokens, ',').map(function (t) { return getTokenValue(t[0]); });
                    var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                    if (endDefOfDef === -1) {
                        throw "Can't find : for def";
                    }
                    var instructionLines = this.tokensToInstructionLines(instruction.tokens, getStartLine(instruction.tokens[endDefOfDef + 1]));
                    var funcAst = {
                        name: funcName,
                        body: [],
                        funcs: []
                    };
                    this.instructionsToNodes(instructionLines, funcAst);
                    ast.funcs.push(new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0])));
                }
                else if (getTokenValue(firstToken) === 'if') {
                    var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                    if (endDefOfDef === -1) {
                        throw "Can't find : for if";
                    }
                    var ifBody = getBody(instruction.tokens, endDefOfDef + 1);
                    var conditionTokens = instruction.tokens.slice(1, endDefOfDef);
                    var conditionNode = findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)
                        ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)
                        : this.createExpressionNode(conditionTokens);
                    // elifs
                    var elifNodes = [];
                    while (instructions.length > i + 1 &&
                        getTokenValue(instructions[i + 1].tokens[0]) === 'elif') {
                        var elifInstruction = instructions[++i];
                        var endOfElif = findTokenValueIndex(elifInstruction.tokens, function (v) { return v === ':'; });
                        var conditionTokens_1 = elifInstruction.tokens.slice(1, endDefOfDef);
                        var elifConditionNode = findIndexes(conditionTokens_1, OperationTypes.Logical, logicOpIndexes)
                            ? this.groupLogicalOperations(logicOpIndexes, conditionTokens_1)
                            : this.createExpressionNode(conditionTokens_1);
                        var elifBody = getBody(elifInstruction.tokens, endOfElif + 1);
                        elifNodes.push(new ElifNode(elifConditionNode, elifBody, getTokenLoc(elifInstruction.tokens[0])));
                    }
                    // else
                    var elseBody = undefined;
                    if (instructions.length > i + 1 &&
                        getTokenValue(instructions[i + 1].tokens[0]) === 'else' &&
                        getTokenValue(instructions[i + 1].tokens[1]) === ':') {
                        elseBody = getBody(instructions[i + 1].tokens, 2);
                        i++;
                    }
                    ast.body.push(new IfNode(conditionNode, ifBody, elifNodes, elseBody, getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'try') {
                    if (getTokenValue(instruction.tokens[1]) !== ':') {
                        throw "'try' statement should be followed by ':'";
                    }
                    var tryBody = getBody(instruction.tokens, 2);
                    var excepts = [];
                    var elseBody = undefined;
                    var finallyBody = undefined;
                    while (instructions.length > i + 1 &&
                        (getTokenValue(instructions[i + 1].tokens[0]) === 'else' ||
                            getTokenValue(instructions[i + 1].tokens[0]) === 'except' ||
                            getTokenValue(instructions[i + 1].tokens[0]) === 'finally')) {
                        if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {
                            if (elseBody) {
                                throw new Error("Only one 'else' is allowed in a 'try'");
                            }
                            elseBody = getBody(instructions[i + 1].tokens, 2);
                        }
                        if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {
                            if (finallyBody) {
                                throw new Error("Only one 'else' is allowed in a 'try'");
                            }
                            finallyBody = getBody(instructions[i + 1].tokens, 2);
                        }
                        if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {
                            var endIndex = findTokenValueIndex(instructions[i + 1].tokens, function (v) { return v === ':'; });
                            var except = {};
                            if (endIndex === 2) {
                                except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) };
                            }
                            else if (endIndex === 3) {
                                except.error = {
                                    name: getTokenValue(instructions[i + 1].tokens[1]),
                                    alias: getTokenValue(instructions[i + 1].tokens[2])
                                };
                            }
                            else if (endIndex === 4) {
                                except.error = {
                                    name: getTokenValue(instructions[i + 1].tokens[1]),
                                    alias: getTokenValue(instructions[i + 1].tokens[3])
                                };
                            }
                            else if (endIndex !== 1) {
                                throw new Error("Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)");
                            }
                            except.body = getBody(instructions[i + 1].tokens, endIndex + 1);
                            excepts.push(except);
                        }
                        i++;
                    }
                    if (!excepts.length) {
                        throw new Error('Except: is missing');
                    }
                    ast.body.push(new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'continue') {
                    ast.body.push(new ContinueNode());
                }
                else if (getTokenValue(firstToken) === 'break') {
                    ast.body.push(new BreakNode());
                }
                else if (getTokenValue(firstToken) === 'return') {
                    ast.body.push(new ReturnNode(instruction.tokens.length > 1
                        ? this.createExpressionNode(instruction.tokens.slice(1))
                        : undefined, getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'raise') {
                    if (instruction.tokens.length === 1) {
                        throw new Error("Incorrect 'raise' usage. Please specify error name and message ");
                    }
                    var errorName = getTokenValue(instruction.tokens[1]);
                    // const errorMessage =
                    //   instruction.tokens.length == 5 &&
                    //   getTokenValue(instruction.tokens[2]) === '(' &&
                    //   getTokenValue(instruction.tokens[4]) === ')'
                    //     ? (getTokenValue(instruction.tokens[3]) as string)
                    //     : undefined;
                    var errMsg = this.createExpressionNode(instruction.tokens.slice(1));
                    ast.body.push(new RaiseNode(errorName, errMsg, getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'for') {
                    var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                    if (endDefOfDef === -1) {
                        throw "Can't find : for if";
                    }
                    var itemVarName = getTokenValue(instruction.tokens[1]);
                    var sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef));
                    var forBody = getBody(instruction.tokens, endDefOfDef + 1);
                    ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'while') {
                    var endDefOfDef = findTokenValueIndex(instruction.tokens, function (v) { return v === ':'; });
                    if (endDefOfDef === -1) {
                        throw "Can't find : for [while]";
                    }
                    var conditionTokens = instruction.tokens.slice(1, endDefOfDef);
                    var conditionNode = findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)
                        ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)
                        : this.createExpressionNode(conditionTokens);
                    var body = getBody(instruction.tokens, endDefOfDef + 1);
                    ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'import') {
                    var asIndex = findTokenValueIndex(instruction.tokens, function (v) { return v === 'as'; });
                    if (asIndex < 0) {
                        asIndex = instruction.tokens.length;
                    }
                    var module_1 = {
                        name: instruction.tokens
                            .slice(1, asIndex)
                            .map(function (t) { return getTokenValue(t); })
                            .join(''),
                        alias: instruction.tokens
                            .slice(asIndex + 1)
                            .map(function (t) { return getTokenValue(t); })
                            .join('') || undefined
                    };
                    var body = {}; // empty for now
                    ast.body.push(new ImportNode(module_1, body, undefined, getTokenLoc(firstToken)));
                }
                else if (getTokenValue(firstToken) === 'from') {
                    var importIndex = findTokenValueIndex(instruction.tokens, function (v) { return v === 'import'; });
                    if (importIndex < 0) {
                        throw Error("'import' must follow 'from'");
                    }
                    var module_2 = {
                        name: instruction.tokens
                            .slice(1, importIndex)
                            .map(function (t) { return getTokenValue(t); })
                            .join('')
                    };
                    var parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',').map(function (t) {
                        return {
                            name: getTokenValue(t[0]),
                            alias: t.length === 3 ? getTokenValue(t[2]) : undefined
                        };
                    });
                    var body = {}; // empty for now
                    ast.body.push(new ImportNode(module_2, body, parts, getTokenLoc(firstToken)));
                }
                else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {
                    var assignTokens = splitTokens(instruction.tokens, '=');
                    var target = this.createExpressionNode(assignTokens[0]);
                    var source = this.createExpressionNode(assignTokens[1]);
                    ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));
                }
                else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {
                    ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));
                }
                else {
                    ast.body.push(this.createExpressionNode(instruction.tokens));
                }
            }
        };
        Parser.prototype.sliceWithBrackets = function (a, begin, end) {
            // if expression is in brackets, then we need clean brackets
            if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {
                begin++;
                end--;
            }
            return a.slice(begin, end);
        };
        Parser.prototype.groupComparisonOperations = function (indexes, tokens) {
            var start = 0;
            var leftNode = null;
            for (var i = 0; i < indexes.length; i++) {
                var opToken = getTokenValue(tokens[indexes[i]]);
                leftNode = leftNode
                    ? leftNode
                    : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]));
                var endInd = i + 1 < indexes.length ? indexes[i + 1] : tokens.length;
                var rightNode = this.createExpressionNode(this.sliceWithBrackets(tokens, indexes[i] + 1, endInd));
                leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));
            }
            return leftNode;
        };
        Parser.prototype.groupLogicalOperations = function (logicOp, tokens) {
            var start = 0;
            var logicItems = [];
            for (var i = 0; i < logicOp.length; i++) {
                var opToken = tokens[logicOp[i]];
                var logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);
                logicItems.push({
                    node: this.createExpressionNode(logicalSlice),
                    op: getTokenValue(opToken)
                });
                start = logicOp[i] + 1;
            }
            logicItems.push({
                node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))
            });
            var lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));
            return lop;
        };
        Parser.prototype.tokensToInstructionLines = function (tokens, startLine) {
            var lines = [];
            var column = 0;
            var line = new InstructionLine();
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                var sLine = getStartLine(token);
                var sColumn = getStartColumn(token);
                var value = getTokenValue(token);
                this._currentToken = token;
                if (sLine >= startLine) {
                    if (column === sColumn && !')}]'.includes(value)) {
                        lines.push(line);
                        line = new InstructionLine();
                    }
                    line.tokens.push(token);
                    // first line defines a minimum indent
                    if (column === 0) {
                        column = sColumn;
                    }
                    // stop looping through if line has less indent
                    // it means the corrent block finished
                    if (sColumn < column) {
                        break;
                    }
                }
            }
            if (line.tokens.length) {
                lines.push(line);
            }
            return lines;
        };
        Parser.prototype.createExpressionNode = function (tokens) {
            var _this = this;
            if (tokens.length === 0) {
                throw new Error("Tokens length can't empty.");
            }
            var lastToken = tokens[tokens.length - 1];
            if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {
                throw new Error("Unexpected symbol ';' in the end");
            }
            this._currentToken = tokens[0];
            // const or variable
            if (tokens.length === 1 || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')) {
                var firstToken = tokens[0];
                var tokenType = getTokenType(firstToken);
                if (isTokenTypeLiteral(tokenType)) {
                    return new ConstNode(firstToken);
                }
                else if (tokenType === TokenTypes.Identifier) {
                    return new GetSingleVarNode(firstToken, (tokens.length === 2 && getTokenValue(tokens[1]) === '?') || undefined);
                }
                throw Error("Unhandled single token: '".concat(JSON.stringify(firstToken), "'"));
            }
            // arrow function
            var arrowFuncParts = splitTokens(tokens, '=>');
            if (arrowFuncParts.length > 1) {
                var pArray = getTokenValue(arrowFuncParts[0][0]) === '('
                    ? arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)
                    : arrowFuncParts[0];
                var params = splitTokens(pArray, ',').map(function (t) { return getTokenValue(t[0]); });
                var instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);
                var funcAst = {
                    name: this._moduleName,
                    body: [],
                    funcs: []
                };
                this.instructionsToNodes(instructionLines, funcAst);
                return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));
            }
            // comparison operations
            var comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);
            if (comparissonIndexes.length) {
                return this.groupComparisonOperations(comparissonIndexes, tokens);
            }
            // create arithmetic expression
            var ops = findOperators(tokens);
            if (ops.length) {
                var prevNode = null;
                for (var i = 0; i < ops.length; i++) {
                    var opIndex = ops[i];
                    var op = getTokenValue(tokens[opIndex]);
                    var nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;
                    var nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;
                    if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {
                        var rightNode = null;
                        // iterate through all continuous '*', '/' operations
                        do {
                            var nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;
                            var leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);
                            var rightSlice2 = this.sliceWithBrackets(tokens, nextOpIndex + 1, nextOpIndex2 || tokens.length);
                            var left2 = this.createExpressionNode(leftSlice2);
                            var right2 = this.createExpressionNode(rightSlice2);
                            rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));
                            i++;
                            nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;
                            nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;
                        } while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'));
                        // add up result
                        if (prevNode === null) {
                            var leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);
                            prevNode = this.createExpressionNode(leftSlice);
                        }
                        prevNode = new BinOpNode(prevNode, op, rightNode, getTokenLoc(tokens[0]));
                    }
                    else {
                        var leftSlice = prevNode ? [] : this.sliceWithBrackets(tokens, 0, opIndex);
                        var rightSlice = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex || tokens.length);
                        var left = prevNode || this.createExpressionNode(leftSlice);
                        var right = this.createExpressionNode(rightSlice);
                        prevNode = new BinOpNode(left, op, right, getTokenLoc(tokens[0]));
                    }
                }
                if (prevNode === null) {
                    throw Error("Can't create node ...");
                }
                return prevNode;
            }
            // create chaining calls
            var inds = findChainingCallTokensIndexes(tokens);
            if (inds.length > 0) {
                var chainingGroup = splitTokensByIndexes(tokens, inds);
                var innerNodes = [];
                for (var i = 0; i < chainingGroup.length; i++) {
                    var chainLinkTokenks = chainingGroup[i];
                    if (i !== 0 && getTokenValue(chainLinkTokenks[0]) === '[') {
                        var nullCoelsing = getTokenValue(chainLinkTokenks[chainLinkTokenks.length - 1]) === '?';
                        if (nullCoelsing) {
                            chainLinkTokenks.pop();
                        }
                        var paramsTokensSlice = chainLinkTokenks.slice(1, chainLinkTokenks.length - 1);
                        var paramsNodes = this.createExpressionNode(paramsTokensSlice);
                        innerNodes.push(new ChainingObjectAccessNode(paramsNodes, nullCoelsing, getTokenLoc(chainLinkTokenks[0])));
                        continue;
                    }
                    innerNodes.push(this.createExpressionNode(chainLinkTokenks));
                }
                return new ChainingCallsNode(innerNodes, getTokenLoc(tokens[0]));
            }
            // create function call node
            if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {
                var isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';
                if (isNullCoelsing) {
                    // remove '?'
                    tokens.pop();
                }
                var name_1 = getTokenValue(tokens[0]);
                var paramsTokensSlice = tokens.slice(2, tokens.length - 1);
                var paramsTokens = splitTokens(paramsTokensSlice, ',');
                var paramsNodes = paramsTokens.map(function (tkns) { return _this.createExpressionNode(tkns); });
                var node = new FunctionCallNode(name_1, paramsNodes, getTokenLoc(tokens[0]));
                node.nullCoelsing = isNullCoelsing || undefined;
                return node;
            }
            // create Object Node
            if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {
                var keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');
                var props = [];
                for (var i = 0; i < keyValueTokens.length; i++) {
                    if (!keyValueTokens[i].length) {
                        continue;
                    }
                    var keyValue = splitTokens(keyValueTokens[i], ':');
                    if (keyValue.length === 1) {
                        var pInfo = {
                            name: new ConstNode(keyValue[0][0]),
                            value: this.createExpressionNode(keyValue[0])
                        };
                        props.push(pInfo);
                    }
                    else if (keyValue.length === 2) {
                        var name_2 = null;
                        var namePart = keyValue[0];
                        if (namePart.length === 1) {
                            name_2 = new ConstNode(namePart[0]);
                        }
                        else if (getTokenValue(namePart[0]) === '[' &&
                            getTokenValue(namePart[namePart.length - 1]) === ']') {
                            name_2 = this.createExpressionNode(namePart.slice(1, namePart.length - 1));
                        }
                        else {
                            throw new Error("Incorrect JSON. Can't resolve Key field. That should either constant or expression in []");
                        }
                        var pInfo = {
                            name: name_2,
                            value: this.createExpressionNode(keyValue[1])
                        };
                        props.push(pInfo);
                    }
                    else {
                        throw Error('Incorrect JSON');
                    }
                }
                return new CreateObjectNode(props, getTokenLoc(tokens[0]));
            }
            // create Array Node
            if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {
                var items = splitTokens(tokens.splice(1, tokens.length - 2), ',')
                    .filter(function (tkns) { return tkns === null || tkns === void 0 ? void 0 : tkns.length; })
                    .map(function (tkns) { return _this.createExpressionNode(tkns); });
                return new CreateArrayNode(items, getTokenLoc(tokens[0]));
            }
            throw Error("Undefined node '".concat(getTokenValue(tokens[0]), "'."));
        };
        return Parser;
    }());

    var SeparatorsMap = {
        '\n': ['\n'],
        '=': ['=', '==', '=>'],
        '+': ['+', '++', '+='],
        '-': ['-', '--', '-='],
        '*': ['*', '**', '*='],
        '/': ['/', '//', '/='],
        '.': ['.'],
        '?': ['?'],
        '!': ['!='],
        ':': [':'],
        ',': [','],
        '>': ['>', '>='],
        '<': ['<', '<=', '<>'],
        '(': ['('],
        ')': [')'],
        '{': ['{'],
        '}': ['}'],
        '[': ['['],
        ']': [']']
    };
    var escapeChars = ['"', "'", '\\'];
    var Keywords = ['async', 'def', 'for', 'while', 'if', 'return', 'in'];
    var Tokenizer = /** @class */ (function () {
        function Tokenizer() {
            this._startLine = 1;
            this._startColumn = 1;
            this._currentLine = 1;
            this._currentColumn = 1;
            this._tokenText = '';
            this._cursor = 0;
            this._script = '';
        }
        Object.defineProperty(Tokenizer.prototype, "tokenText", {
            get: function () {
                return this._tokenText;
            },
            set: function (value) {
                if (!this._tokenText && value) {
                    this._startLine = this._currentLine;
                    this._startColumn = this._currentColumn;
                }
                this._tokenText = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Splits script code into a tokens
         * @param script A jsPython text
         */
        Tokenizer.prototype.tokenize = function (script) {
            if (!script || !script.length) {
                return [];
            }
            script = script
                // eslint-disable-next-line no-control-regex
                .replace(new RegExp('\t', 'g'), '  ') // replace all tabs with 2 spaces
                // eslint-disable-next-line no-control-regex
                .replace(new RegExp('\r', 'g'), ''); // remove all \r symbols
            this._script = script;
            this._cursor = 0;
            this._startLine = 1;
            this._startColumn = 1;
            this._currentLine = 1;
            this._currentColumn = 1;
            var tokens = [];
            var first = true;
            // handle initial spaces
            while (script[this._cursor] === '\n') {
                this.incrementCursor();
                if (first) {
                    this._currentLine++;
                    first = false;
                }
                this._currentColumn = 1;
            }
            do {
                var symbol = script[this._cursor];
                if (symbol == ' ' && this.tokenText.length !== 0) {
                    this.tokenText = this.processToken(this.tokenText, tokens);
                    continue;
                }
                else if (SeparatorsMap[symbol] !== undefined && !this.isPartOfNumber(symbol, tokens)) {
                    // handle numbers with floating point e.g. 3.14
                    this.tokenText = this.processToken(this.tokenText, tokens);
                    this.tokenText = symbol;
                    var sepsMap = SeparatorsMap[symbol];
                    if (sepsMap.length >= 1) {
                        // process longer operators
                        while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {
                            this.tokenText += script[this.incrementCursor()];
                        }
                    }
                    this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);
                }
                else if (symbol === '#') {
                    var first_1 = true;
                    while (script[this.incrementCursor()] !== '\n') {
                        this.tokenText += script[this._cursor];
                        // correct start column
                        if (first_1) {
                            first_1 = false;
                            this._startColumn = this._startColumn - 1;
                        }
                        if (this._cursor + 1 >= script.length)
                            break;
                    }
                    this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);
                }
                else if (symbol === '"' || symbol === "'") {
                    // remember either it is single or double quote
                    var q = symbol;
                    // we are not expecting token to be added here.
                    // it should pass a failt to parser
                    this.tokenText = this.processToken(this.tokenText, tokens);
                    // handle """ comment """"
                    if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {
                        var cLine = this._currentLine;
                        var cColumn = this._currentColumn;
                        this.incrementCursor(2);
                        var passCond = true;
                        while (passCond) {
                            this.tokenText += script[this.incrementCursor()];
                            if (this._cursor + 3 >= script.length ||
                                (script[this._cursor + 1] === q &&
                                    script[this._cursor + 2] === q &&
                                    script[this._cursor + 3] === q)) {
                                break;
                            }
                        }
                        // a special case when multiline string
                        this._startLine = cLine;
                        this._startColumn = cColumn;
                        this.incrementCursor(3);
                    }
                    else {
                        while (script[this.incrementCursor()] !== q) {
                            if (script[this._cursor] === '\\' &&
                                escapeChars.indexOf(script[this._cursor + 1]) >= 0) {
                                this._cursor++;
                            }
                            this.tokenText += script[this._cursor];
                            if (this._cursor + 1 >= script.length) {
                                throw new Error("Line ".concat(this._startLine, ": End of string missing."));
                            }
                        }
                        //start column needs to take into account a begining quote, not just a string
                        this._startColumn--;
                    }
                    // a special case when empty string
                    if (this.tokenText.length === 0) {
                        this._startLine = this._currentLine;
                        this._startColumn = this._currentColumn;
                    }
                    this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);
                }
                else if (symbol != ' ') {
                    this.tokenText += symbol;
                }
            } while (this.incrementCursor() < script.length);
            this.processToken(this.tokenText, tokens);
            return tokens;
        };
        Tokenizer.prototype.incrementCursor = function (count) {
            if (count === void 0) { count = 1; }
            for (var i = 0; i < count; i++) {
                this._cursor = this._cursor + 1;
                if (this._script[this._cursor] === '\n') {
                    this._currentLine++;
                    this._currentColumn = 0;
                }
                else {
                    this._currentColumn++;
                }
            }
            return this._cursor;
        };
        Tokenizer.prototype.recognizeToken = function (tokenText, type) {
            if (type === void 0) { type = null; }
            var value = tokenText;
            if (type === null) {
                if (tokenText === 'null') {
                    type = TokenTypes.LiteralNull;
                    value = null;
                }
                else if (tokenText === 'true' || tokenText === 'false') {
                    type = TokenTypes.LiteralBool;
                    value = tokenText === 'true';
                }
                else if (this.parseNumberOrNull(tokenText) !== null) {
                    type = TokenTypes.LiteralNumber;
                    value = this.parseNumberOrNull(tokenText);
                }
                else if (Keywords.indexOf(tokenText) >= 0) {
                    type = TokenTypes.Keyword;
                }
                else {
                    type = TokenTypes.Identifier;
                }
            }
            return {
                value: value,
                type: type
            };
        };
        Tokenizer.prototype.processToken = function (strToken, tokens, allowEmptyString, type) {
            if (allowEmptyString === void 0) { allowEmptyString = false; }
            if (type === void 0) { type = null; }
            // ignore empty tokens
            if ((!strToken.length && !allowEmptyString) || strToken === '\n')
                return '';
            var token = this.recognizeToken(strToken, type);
            tokens.push([
                token.value,
                Uint16Array.of(token.type, this._startLine, this._startColumn, this._currentLine, this._currentColumn)
            ]);
            return '';
        };
        Tokenizer.prototype.parseNumberOrNull = function (value) {
            if (typeof value === 'number') {
                return value;
            }
            if (!value || typeof value !== 'string') {
                return null;
            }
            value = value.trim();
            // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number
            for (var i = value.length - 1; i >= 0; i--) {
                var d = value.charCodeAt(i);
                if (d < 48 || d > 57) {
                    // '.' - 46 ',' - 44 '-' - 45(but only first char)
                    if (d !== 46 && d !== 44 && (d !== 45 || i !== 0))
                        return null;
                }
            }
            var res = parseFloat(value);
            return !isNaN(res) ? res : null;
        };
        Tokenizer.prototype.isPartOfNumber = function (symbol, currentTokens) {
            if (symbol === '-' && !this.tokenText.length) {
                // '-' needs to be handled e.g. -3; 2 + -2 etc
                var prevToken = currentTokens.length !== 0 ? currentTokens[currentTokens.length - 1] : null;
                return (prevToken === null ||
                    (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')'));
            }
            else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {
                return true;
            }
            return false;
        };
        return Tokenizer;
    }());

    function jsPython() {
        return Interpreter.create();
    }
    var Interpreter = /** @class */ (function () {
        function Interpreter() {
            this.initialScope = __assign({}, INITIAL_SCOPE);
            this._lastExecutionContext = null;
        }
        Interpreter.create = function () {
            return new Interpreter();
        };
        Object.defineProperty(Interpreter.prototype, "initialExecutionContext", {
            get: function () {
                return this.initialScope;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Interpreter.prototype, "lastExecutionContext", {
            get: function () {
                return this._lastExecutionContext;
            },
            enumerable: false,
            configurable: true
        });
        Interpreter.prototype.cleanUp = function () {
            this._lastExecutionContext = null;
        };
        Interpreter.prototype.jsPythonInfo = function () {
            return INITIAL_SCOPE.jsPython();
        };
        Interpreter.prototype.tokenize = function (script) {
            var tokenizer = new Tokenizer();
            return tokenizer.tokenize(script);
        };
        Interpreter.prototype.parse = function (script, moduleName) {
            if (moduleName === void 0) { moduleName = 'main.jspy'; }
            var tokenizer = new Tokenizer();
            var parser = new Parser();
            var jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);
            return jspyAst;
        };
        Interpreter.prototype.eval = function (codeOrAst, scope, entryFunctionName, moduleName) {
            if (scope === void 0) { scope = {}; }
            if (entryFunctionName === void 0) { entryFunctionName = ''; }
            if (moduleName === void 0) { moduleName = 'main.jspy'; }
            var ast = typeof codeOrAst === 'string'
                ? this.parse(codeOrAst, moduleName)
                : codeOrAst;
            var blockContext = {
                moduleName: moduleName,
                cancellationToken: { cancel: false },
                blockScope: new Scope(scope)
            };
            blockContext.blockScope.set('printExecutionContext', function () {
                return console.log(blockContext.blockScope.getScope());
            });
            blockContext.blockScope.set('getExecutionContext', function () { return blockContext.blockScope.getScope(); });
            this._lastExecutionContext = blockContext.blockScope.getScope();
            var result = new Evaluator().evalBlock(ast, blockContext);
            if (!entryFunctionName || !entryFunctionName.length) {
                return result;
            }
            else {
                var funcName = Array.isArray(entryFunctionName) ? entryFunctionName[0] : entryFunctionName;
                var funcParams = Array.isArray(entryFunctionName) ? entryFunctionName.slice(1) : [];
                var func = blockContext.blockScope.get(funcName);
                if (typeof func !== 'function') {
                    throw Error("Function ".concat(entryFunctionName, " does not exists or not a function"));
                }
                return func.apply(void 0, funcParams);
            }
        };
        Interpreter.prototype.evalAsync = function (codeOrAst, scope, entryFunctionName, moduleName, ctxInitialized) {
            if (scope === void 0) { scope = {}; }
            if (entryFunctionName === void 0) { entryFunctionName = ''; }
            if (moduleName === void 0) { moduleName = 'main.jspy'; }
            return __awaiter(this, void 0, void 0, function () {
                var ast, evaluator, blockContext, result, funcName, funcParams, func;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            ast = typeof codeOrAst === 'string'
                                ? this.parse(codeOrAst, moduleName)
                                : codeOrAst;
                            evaluator = new EvaluatorAsync();
                            blockContext = {
                                moduleName: moduleName,
                                cancellationToken: { cancel: false },
                                blockScope: new Scope(scope)
                            };
                            if (typeof ctxInitialized === 'function') {
                                ctxInitialized(blockContext);
                            }
                            blockContext.blockScope.set('printExecutionContext', function () {
                                return console.log(blockContext.blockScope.getScope());
                            });
                            blockContext.blockScope.set('getExecutionContext', function () { return blockContext.blockScope.getScope(); });
                            this._lastExecutionContext = blockContext.blockScope.getScope();
                            return [4 /*yield*/, evaluator
                                    .registerJsonFileLoader(function (modulePath) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, (this.moduleLoader
                                                    ? this.moduleLoader(modulePath)
                                                    : Promise.reject('ModuleLoader is not registered'))];
                                            case 1: return [2 /*return*/, _a.sent()];
                                        }
                                    });
                                }); })
                                    .registerModuleParser(function (modulePath) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.moduleParser(modulePath)];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                }); }); })
                                    .registerBlockContextFactory(function (moduleName, ast) {
                                    // enrich context
                                    var newContext = _this.assignImportContext(ast, scope);
                                    var moduleContext = {
                                        moduleName: moduleName,
                                        blockScope: new Scope(newContext),
                                        cancellationToken: blockContext.cancellationToken
                                    };
                                    moduleContext.blockScope.set('printExecutionContext', function () {
                                        return console.log(moduleContext.blockScope.getScope());
                                    });
                                    moduleContext.blockScope.set('getExecutionContext', function () {
                                        return moduleContext.blockScope.getScope();
                                    });
                                    return moduleContext;
                                })
                                    .evalBlockAsync(ast, blockContext)];
                        case 1:
                            result = _a.sent();
                            if (!(!entryFunctionName || !entryFunctionName.length)) return [3 /*break*/, 2];
                            return [2 /*return*/, result];
                        case 2:
                            funcName = Array.isArray(entryFunctionName) ? entryFunctionName[0] : entryFunctionName;
                            funcParams = Array.isArray(entryFunctionName) ? entryFunctionName.slice(1) : [];
                            func = blockContext.blockScope.get(funcName);
                            if (typeof func !== 'function') {
                                throw Error("Function ".concat(entryFunctionName, " does not exists or not a function"));
                            }
                            return [4 /*yield*/, func.apply(void 0, funcParams)];
                        case 3: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        /**
         * Compatibility method (with v1). !
         */
        Interpreter.prototype.evaluate = function (script, context, entryFunctionName, moduleName, ctxInitialized) {
            if (context === void 0) { context = {}; }
            if (entryFunctionName === void 0) { entryFunctionName = ''; }
            if (moduleName === void 0) { moduleName = 'main.jspy'; }
            return __awaiter(this, void 0, void 0, function () {
                var ast, globalScope;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!script || !script.length) {
                                return [2 /*return*/, null];
                            }
                            ast = this.parse(script, moduleName);
                            context = context && typeof context === 'object' ? context : {};
                            context = this.assignImportContext(ast, context);
                            globalScope = __assign(__assign({}, this.initialScope), context);
                            return [4 /*yield*/, this.evalAsync(ast, globalScope, entryFunctionName, moduleName, ctxInitialized)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Interpreter.prototype.registerPackagesLoader = function (loader) {
            if (typeof loader === 'function') {
                this.packageLoader = loader;
            }
            else {
                throw Error('PackagesLoader');
            }
            return this;
        };
        Interpreter.prototype.registerModuleLoader = function (loader) {
            if (typeof loader === 'function') {
                this.moduleLoader = loader;
            }
            else {
                throw Error('ModuleLoader should be a function');
            }
            return this;
        };
        Interpreter.prototype.addFunction = function (funcName, fn) {
            this.initialScope[funcName] = fn;
            return this;
        };
        Interpreter.prototype.assignGlobalContext = function (obj) {
            Object.assign(this.initialScope, obj);
            return this;
        };
        Interpreter.prototype.hasFunction = function (scripts, funcName) {
            if (scripts === void 0) { scripts = ''; }
            return scripts.indexOf("def ".concat(funcName)) > -1;
        };
        Interpreter.prototype.assignImportContext = function (ast, context) {
            var nodeToPackage = function (im) {
                var _a;
                return {
                    name: im.module.name,
                    as: im.module.alias,
                    properties: (_a = im.parts) === null || _a === void 0 ? void 0 : _a.map(function (p) { return ({ name: p.name, as: p.alias }); })
                };
            };
            var importNodes = ast.body.filter(function (n) { return n.type === 'import'; });
            var jsImport = importNodes
                .filter(function (im) { return getImportType(im.module.name) === 'jsPackage'; })
                .map(function (im) { return nodeToPackage(im); });
            if (jsImport.length && this.packageLoader) {
                var libraries = this.packageResolver(jsImport);
                context = __assign(__assign({}, context), libraries);
            }
            return context;
        };
        Interpreter.prototype.moduleParser = function (modulePath) {
            return __awaiter(this, void 0, void 0, function () {
                var content;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.moduleLoader) {
                                throw new Error('Module Loader is not registered');
                            }
                            return [4 /*yield*/, this.moduleLoader(modulePath)];
                        case 1:
                            content = _a.sent();
                            return [2 /*return*/, this.parse(content, modulePath)];
                    }
                });
            });
        };
        Interpreter.prototype.packageResolver = function (packages) {
            var _this = this;
            if (!this.packageLoader) {
                throw Error('Package loader not provided.');
            }
            var libraries = {};
            packages.forEach(function (_a) {
                var name = _a.name, as = _a.as, properties = _a.properties;
                var lib = (_this.packageLoader && _this.packageLoader(name)) || {};
                if (properties === null || properties === void 0 ? void 0 : properties.length) {
                    properties.forEach(function (prop) {
                        libraries[prop.as || prop.name] = lib[prop.name];
                    });
                }
                else if (as) {
                    libraries[as] = lib;
                }
                else {
                    libraries[name] = lib;
                }
                if (as) {
                    libraries[as] = lib;
                }
            });
            return libraries;
        };
        return Interpreter;
    }());

    exports.Interpreter = Interpreter;
    exports.jsPython = jsPython;

}));
//# sourceMappingURL=jspython-interpreter.js.map
