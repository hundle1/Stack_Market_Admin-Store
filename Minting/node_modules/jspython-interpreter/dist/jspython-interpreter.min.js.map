{"version":3,"file":"jspython-interpreter.min.js","sources":["../src/common/utils.ts","../src/common/operators.ts","../src/common/token-types.ts","../src/common/ast-types.ts","../src/evaluator/scope.ts","../src/evaluator/evaluator.ts","../src/evaluator/evaluatorAsync.ts","../src/initialScope.ts","../src/parser/parser.ts","../src/tokenizer/tokenizer.ts","../src/interpreter.ts"],"sourcesContent":["export function parseDatetimeOrNull(value: string | number | Date): Date | null {\r\n  if (!value) {\r\n    return null;\r\n  }\r\n  if (typeof value === 'number') {\r\n    return new Date(value);\r\n  }\r\n  if (value instanceof Date && !isNaN(value.valueOf())) {\r\n    return value;\r\n  }\r\n  // only string values can be converted to Date\r\n  if (typeof value !== 'string') {\r\n    return null;\r\n  }\r\n\r\n  const strValue = String(value);\r\n  if (!strValue.length) {\r\n    return null;\r\n  }\r\n\r\n  const parseMonth = (mm: string): number => {\r\n    if (!mm || !mm.length) {\r\n      return NaN;\r\n    }\r\n\r\n    const m = parseInt(mm, 10);\r\n    if (!isNaN(m)) {\r\n      return m - 1;\r\n    }\r\n\r\n    // make sure english months are coming through\r\n    if (mm.startsWith('jan')) {\r\n      return 0;\r\n    }\r\n    if (mm.startsWith('feb')) {\r\n      return 1;\r\n    }\r\n    if (mm.startsWith('mar')) {\r\n      return 2;\r\n    }\r\n    if (mm.startsWith('apr')) {\r\n      return 3;\r\n    }\r\n    if (mm.startsWith('may')) {\r\n      return 4;\r\n    }\r\n    if (mm.startsWith('jun')) {\r\n      return 5;\r\n    }\r\n    if (mm.startsWith('jul')) {\r\n      return 6;\r\n    }\r\n    if (mm.startsWith('aug')) {\r\n      return 7;\r\n    }\r\n    if (mm.startsWith('sep')) {\r\n      return 8;\r\n    }\r\n    if (mm.startsWith('oct')) {\r\n      return 9;\r\n    }\r\n    if (mm.startsWith('nov')) {\r\n      return 10;\r\n    }\r\n    if (mm.startsWith('dec')) {\r\n      return 11;\r\n    }\r\n\r\n    return NaN;\r\n  };\r\n\r\n  const correctYear = (yy: number): number => {\r\n    if (yy < 100) {\r\n      return yy < 68 ? yy + 2000 : yy + 1900;\r\n    } else {\r\n      return yy;\r\n    }\r\n  };\r\n\r\n  const validDateOrNull = (\r\n    yyyy: number,\r\n    month: number,\r\n    day: number,\r\n    hours: number,\r\n    mins: number,\r\n    ss: number\r\n  ): Date | null => {\r\n    if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) {\r\n      return null;\r\n    }\r\n\r\n    const dd = new Date(yyyy, month, day, hours, mins, ss, 0);\r\n    return !isNaN(dd.valueOf()) ? dd : null;\r\n  };\r\n\r\n  const strTokens = strValue\r\n    .replace('T', ' ')\r\n    .toLowerCase()\r\n    .split(/[: /-]/);\r\n  const dt = strTokens.map(parseFloat);\r\n\r\n  // try ISO first\r\n  let d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n  if (d) {\r\n    return d;\r\n  }\r\n\r\n  // then UK\r\n  d = validDateOrNull(\r\n    correctYear(dt[2]),\r\n    parseMonth(strTokens[1]),\r\n    dt[0],\r\n    dt[3] || 0,\r\n    dt[4] || 0,\r\n    dt[5] || 0\r\n  );\r\n  if (d) {\r\n    return d;\r\n  }\r\n\r\n  // then US\r\n  d = validDateOrNull(\r\n    correctYear(dt[2]),\r\n    parseMonth(strTokens[0]),\r\n    correctYear(dt[1]),\r\n    dt[3] || 0,\r\n    dt[4] || 0,\r\n    dt[5] || 0\r\n  );\r\n  if (d) {\r\n    return d;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getImportType(name: string): 'jspyModule' | 'jsPackage' | 'json' {\r\n  if (name.startsWith('/') || name.startsWith('./')) {\r\n    return name.endsWith('.json') ? 'json' : 'jspyModule';\r\n  }\r\n\r\n  return 'jsPackage';\r\n}\r\n\r\nfunction jspyErrorMessage(\r\n  error: string,\r\n  module: string,\r\n  line: number,\r\n  column: number,\r\n  message: string\r\n): string {\r\n  return `${error}: ${module}(${line},${column}): ${message}`;\r\n}\r\n\r\nexport class JspyTokenizerError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyTokenizerError', module, line, column, message);\r\n    Object.setPrototypeOf(this, JspyTokenizerError.prototype);\r\n  }\r\n}\r\n\r\nexport class JspyParserError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyParserError', module, line, column, message);\r\n    Object.setPrototypeOf(this, JspyParserError.prototype);\r\n  }\r\n}\r\n\r\nexport class JspyEvalError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyEvalError', module, line, column, message);\r\n    Object.setPrototypeOf(this, JspyEvalError.prototype);\r\n  }\r\n}\r\n\r\nexport class JspyError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public name: string,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyError', module || 'name.jspy', line, column, message);\r\n    Object.setPrototypeOf(this, JspyError.prototype);\r\n  }\r\n}\r\n","export enum OperationTypes {\r\n  Arithmetic,\r\n  Assignment,\r\n  Comparison,\r\n  Logical,\r\n  Membership\r\n}\r\n\r\nexport type AssignmentOperators = '=' | '+=' | '-=' | '*=' | '/=' | '++' | '--';\r\nexport type ArithmeticOperators = '+' | '-' | '*' | '/' | '%' | '**' | '//';\r\nexport type ComparisonOperators = '>' | '>=' | '==' | '!=' | '<>' | '<' | '<=';\r\nexport type LogicalOperators = 'and' | 'or'; // | \"not\" | \"not in\";\r\nexport type MembershipOperators = 'in';\r\n\r\nexport type Operators =\r\n  | AssignmentOperators\r\n  | ArithmeticOperators\r\n  | ComparisonOperators\r\n  | LogicalOperators\r\n  | MembershipOperators;\r\n\r\nexport const OperatorsMap: Map<Operators, OperationTypes> = new Map<Operators, OperationTypes>([\r\n  ['+', OperationTypes.Arithmetic],\r\n  ['-', OperationTypes.Arithmetic],\r\n  ['*', OperationTypes.Arithmetic],\r\n  ['/', OperationTypes.Arithmetic],\r\n  ['%', OperationTypes.Arithmetic],\r\n  ['**', OperationTypes.Arithmetic],\r\n  ['//', OperationTypes.Arithmetic],\r\n\r\n  ['>', OperationTypes.Comparison],\r\n  ['>=', OperationTypes.Comparison],\r\n  ['==', OperationTypes.Comparison],\r\n  ['!=', OperationTypes.Comparison],\r\n  ['<>', OperationTypes.Comparison],\r\n  ['<', OperationTypes.Comparison],\r\n  ['<=', OperationTypes.Comparison],\r\n\r\n  ['and', OperationTypes.Logical],\r\n  ['or', OperationTypes.Logical],\r\n  // \"not\", OperationTypes.Logical],\r\n  // \"not in\", OperationTypes.Logical],\r\n\r\n  ['in', OperationTypes.Membership],\r\n\r\n  ['=', OperationTypes.Assignment],\r\n  ['+=', OperationTypes.Assignment],\r\n  ['-=', OperationTypes.Assignment],\r\n  ['*=', OperationTypes.Assignment],\r\n  ['/=', OperationTypes.Assignment],\r\n  ['++', OperationTypes.Assignment],\r\n  ['--', OperationTypes.Assignment]\r\n]);\r\n\r\nexport type Primitive = string | number | boolean | null;\r\n\r\nexport type ExpressionOperators =\r\n  | ArithmeticOperators\r\n  | ComparisonOperators\r\n  | LogicalOperators\r\n  | MembershipOperators;\r\ntype ExpressionOperation = (l: Primitive, r: Primitive) => Primitive;\r\n\r\nexport const OperationFuncs: Map<ExpressionOperators, ExpressionOperation> = new Map<\r\n  ExpressionOperators,\r\n  ExpressionOperation\r\n>([\r\n  ['+' as ExpressionOperators, ((l, r) => arithmeticOperation(l, r, '+')) as ExpressionOperation],\r\n  ['-' as ExpressionOperators, ((l, r) => arithmeticOperation(l, r, '-')) as ExpressionOperation],\r\n  ['/' as ExpressionOperators, ((l, r) => arithmeticOperation(l, r, '/')) as ExpressionOperation],\r\n  ['*' as ExpressionOperators, ((l, r) => arithmeticOperation(l, r, '*')) as ExpressionOperation],\r\n  ['%' as ExpressionOperators, ((l, r) => arithmeticOperation(l, r, '%')) as ExpressionOperation],\r\n  ['**' as ExpressionOperators, ((l, r) => arithmeticOperation(l, r, '**')) as ExpressionOperation],\r\n  ['//' as ExpressionOperators, ((l, r) => arithmeticOperation(l, r, '//')) as ExpressionOperation],\r\n\r\n  ['>' as ExpressionOperators, ((l, r) => comparissonOperation(l, r, '>')) as ExpressionOperation],\r\n  [\r\n    '>=' as ExpressionOperators,\r\n    ((l, r) => comparissonOperation(l, r, '>=')) as ExpressionOperation\r\n  ],\r\n  ['<' as ExpressionOperators, ((l, r) => comparissonOperation(l, r, '<')) as ExpressionOperation],\r\n  [\r\n    '<=' as ExpressionOperators,\r\n    ((l, r) => comparissonOperation(l, r, '<=')) as ExpressionOperation\r\n  ],\r\n  [\r\n    '==' as ExpressionOperators,\r\n    ((l, r) => comparissonOperation(l, r, '==')) as ExpressionOperation\r\n  ],\r\n  [\r\n    '!=' as ExpressionOperators,\r\n    ((l, r) => comparissonOperation(l, r, '!=')) as ExpressionOperation\r\n  ],\r\n  [\r\n    '<>' as ExpressionOperators,\r\n    ((l, r) => comparissonOperation(l, r, '<>')) as ExpressionOperation\r\n  ],\r\n\r\n  ['and' as ExpressionOperators, ((l, r) => logicalOperation(l, r, 'and')) as ExpressionOperation],\r\n  ['or' as ExpressionOperators, ((l, r) => logicalOperation(l, r, 'or')) as ExpressionOperation],\r\n  // \"not\" as ExpressionOperators, ((l, r) => logicalOperation(l, r, \"not\")) as ExpressionOperation],\r\n  // \"not in\" as ExpressionOperators, ((l, r) => logicalOperation(l, r, \"not in\")) as ExpressionOperation],\r\n\r\n  ['in' as ExpressionOperators, ((l, r) => membershipOperation(l, r, 'in')) as ExpressionOperation]\r\n]);\r\n\r\nfunction membershipOperation(l: Primitive, r: Primitive, op: MembershipOperators): Primitive {\r\n  if (typeof l === 'string') {\r\n    return (l as string).includes(String(r));\r\n  }\r\n\r\n  if (Array.isArray(l)) {\r\n    return (l as unknown[]).includes(r);\r\n  }\r\n\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction logicalOperation(l: Primitive, r: Primitive, op: LogicalOperators): Primitive {\r\n  switch (op) {\r\n    case 'and':\r\n      return l && r;\r\n\r\n    case 'or':\r\n      return l || r;\r\n  }\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction comparissonOperation(l: Primitive, r: Primitive, op: ComparisonOperators): Primitive {\r\n  switch (op) {\r\n    case '==':\r\n      return l === r;\r\n\r\n    case '!=':\r\n      return l !== r;\r\n\r\n    case '<>':\r\n      return l !== r;\r\n\r\n    case '>':\r\n      return (l as number) > (r as number);\r\n\r\n    case '<':\r\n      return (l as number) < (r as number);\r\n\r\n    case '>=':\r\n      return (l as number) >= (r as number);\r\n\r\n    case '<=':\r\n      return (l as number) <= (r as number);\r\n  }\r\n\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction arithmeticOperation(l: Primitive, r: Primitive, op: ArithmeticOperators): Primitive {\r\n  switch (op) {\r\n    case '+':\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      return (l as any) + (r as any);\r\n\r\n    case '-':\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      return (l as any) - (r as any);\r\n\r\n    case '*':\r\n      return (l as number) * (r as number);\r\n\r\n    case '/':\r\n      return (l as number) / (r as number);\r\n\r\n    case '%':\r\n      return (l as number) % (r as number);\r\n\r\n    case '**':\r\n      return Math.pow(l as number, r as number);\r\n  }\r\n\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n","import { OperationTypes, Operators, OperatorsMap } from './operators';\r\n\r\nexport enum TokenTypes {\r\n  Identifier = 0,\r\n  Keyword = 1,\r\n  Separator = 2,\r\n  Operator = 3,\r\n  LiteralNumber = 4,\r\n  LiteralBool = 5,\r\n  LiteralString = 6,\r\n  LiteralNull = 7,\r\n  Comment = 8\r\n}\r\n/**\r\n * Token represent a single considered token in a script. Is represented as an array, where element at:\r\n *  0 : value\r\n *  1 : token details. For a memory and performance reasons we use Uint16Array with 5 elements in it:\r\n *    [\r\n *      0 - tokenType number equivalent of @TokenTypes\r\n *      1 - beginLine\r\n *      2 - beginColumn\r\n *      3 - endLine\r\n *      4 - endColumn\r\n *    ]\r\n * [(value). Uint16Array[5]([tokenType, beginLine, beginColumn, endLine, endColumn])]\r\n * tokenType\r\n */\r\nexport type Token = [string | number | boolean | null, Uint16Array];\r\nexport type TokenValue = string | number | boolean | null;\r\n\r\nexport function isTokenTypeLiteral(tokenType: TokenTypes): boolean {\r\n  return (\r\n    tokenType === TokenTypes.LiteralString ||\r\n    tokenType === TokenTypes.LiteralNumber ||\r\n    tokenType === TokenTypes.LiteralBool ||\r\n    tokenType === TokenTypes.LiteralNull\r\n  );\r\n}\r\n\r\nexport function getTokenType(token: Token): TokenTypes {\r\n  return token[1][0] as TokenTypes;\r\n}\r\n\r\nexport function getTokenValue(token: Token | null): TokenValue {\r\n  return token ? token[0] : null;\r\n}\r\n\r\nexport function getTokenLoc(token: Token): Uint16Array {\r\n  return token[1].subarray(1);\r\n}\r\n\r\nexport function getStartLine(token: Token): number {\r\n  return token[1][1];\r\n}\r\n\r\nexport function getStartColumn(token: Token): number {\r\n  return token[1][2];\r\n}\r\n\r\nexport function getEndLine(token: Token): number {\r\n  return token[1][3];\r\n}\r\n\r\nexport function getEndColumn(token: Token): number {\r\n  return token[1][4];\r\n}\r\n\r\nexport function splitTokensByIndexes(tokens: Token[], sepIndexes: number[]): Token[][] {\r\n  const result: Token[][] = [];\r\n\r\n  if (!tokens.length) {\r\n    return [];\r\n  }\r\n\r\n  let start = 0;\r\n  for (let i = 0; i < sepIndexes.length; i++) {\r\n    const ind = sepIndexes[i];\r\n    if (getTokenValue(tokens[start - 1]) === '[') {\r\n      start = start - 1;\r\n    }\r\n    result.push(tokens.slice(start, ind));\r\n    start = ind + 1;\r\n  }\r\n\r\n  if (getTokenValue(tokens[start - 1]) === '[') {\r\n    start = start - 1;\r\n  }\r\n  result.push(tokens.slice(start, tokens.length));\r\n  return result;\r\n}\r\n\r\nexport function splitTokens(tokens: Token[], separator: string): Token[][] {\r\n  if (!tokens.length) {\r\n    return [];\r\n  }\r\n  const sepIndexes = findTokenValueIndexes(tokens, value => value === separator);\r\n  return splitTokensByIndexes(tokens, sepIndexes);\r\n}\r\n\r\nexport function findTokenValueIndex(\r\n  tokens: Token[],\r\n  predicate: (value: TokenValue) => boolean,\r\n  start = 0\r\n): number {\r\n  for (let i = start; i < tokens.length; i++) {\r\n    if (getTokenType(tokens[i]) === TokenTypes.LiteralString) {\r\n      continue;\r\n    }\r\n\r\n    if (getTokenValue(tokens[i]) === '(') {\r\n      i = skipInnerBrackets(tokens, i, '(', ')');\r\n    } else if (getTokenValue(tokens[i]) === '[') {\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (getTokenValue(tokens[i]) === '{') {\r\n      i = skipInnerBrackets(tokens, i, '{', '}');\r\n    } else if (predicate(getTokenValue(tokens[i]))) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nexport function findChainingCallTokensIndexes(tokens: Token[]): number[] {\r\n  const opIndexes: number[] = [];\r\n\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const tValue = getTokenValue(tokens[i]);\r\n    const tType = getTokenType(tokens[i]);\r\n\r\n    if (tType === TokenTypes.LiteralString) {\r\n      continue;\r\n    }\r\n\r\n    if (tValue === '.') {\r\n      opIndexes.push(i);\r\n    } else if (tValue === '(') {\r\n      i = skipInnerBrackets(tokens, i, '(', ')');\r\n    } else if (tValue === '[' && i === 0) {\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (tValue === '[' && i !== 0) {\r\n      opIndexes.push(i);\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (tValue === '{') {\r\n      i = skipInnerBrackets(tokens, i, '{', '}');\r\n    }\r\n  }\r\n\r\n  return opIndexes;\r\n}\r\n\r\nexport function findTokenValueIndexes(\r\n  tokens: Token[],\r\n  predicate: (value: TokenValue) => boolean\r\n): number[] {\r\n  const opIndexes: number[] = [];\r\n\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const tValue = getTokenValue(tokens[i]);\r\n    const tType = getTokenType(tokens[i]);\r\n\r\n    if (tType === TokenTypes.LiteralString) {\r\n      continue;\r\n    }\r\n\r\n    if (tValue === '(') {\r\n      i = skipInnerBrackets(tokens, i, '(', ')');\r\n    } else if (tValue === '[') {\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (tValue === '{') {\r\n      i = skipInnerBrackets(tokens, i, '{', '}');\r\n    } else if (predicate(tValue)) {\r\n      opIndexes.push(i);\r\n    }\r\n  }\r\n\r\n  return opIndexes;\r\n}\r\n\r\nexport function findOperators(\r\n  tokens: Token[],\r\n  operationType: OperationTypes | null = null\r\n): number[] {\r\n  return !operationType\r\n    ? findTokenValueIndexes(tokens, value => OperatorsMap.has(value as Operators))\r\n    : findTokenValueIndexes(\r\n        tokens,\r\n        value => OperatorsMap.get(value as Operators) === operationType\r\n      );\r\n}\r\n\r\nfunction skipInnerBrackets(\r\n  tokens: Token[],\r\n  i: number,\r\n  openChar: string,\r\n  closeChar: string\r\n): number {\r\n  let innerBrackets = 0;\r\n  while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {\r\n    if (i + 1 >= tokens.length) {\r\n      throw new Error(`Closing '${closeChar}' is missing`);\r\n    }\r\n\r\n    const tokenValue = getTokenValue(tokens[i]);\r\n    if (tokenValue === openChar) {\r\n      innerBrackets++;\r\n    }\r\n    if (tokenValue === closeChar) {\r\n      innerBrackets--;\r\n    }\r\n  }\r\n  return i;\r\n}\r\n","import { ExpressionOperators, LogicalOperators } from './operators';\r\nimport { getTokenLoc, getTokenValue, Token } from './token-types';\r\n\r\nexport type AstNodeType =\r\n  | 'assign'\r\n  | 'binOp'\r\n  | 'const'\r\n  | 'logicalOp'\r\n  | 'getSingleVar'\r\n  | 'setSingleVar'\r\n  | 'chainingCalls'\r\n  | 'chainingObjectAccess'\r\n  | 'funcCall'\r\n  | 'funcDef'\r\n  | 'arrowFuncDef'\r\n  | 'createObject'\r\n  | 'createArray'\r\n  | 'if'\r\n  | 'elif'\r\n  | 'for'\r\n  | 'while'\r\n  | 'tryExcept'\r\n  | 'raise'\r\n  | 'import'\r\n  | 'comment'\r\n  | 'return'\r\n  | 'continue'\r\n  | 'break';\r\n\r\nexport interface NameAlias {\r\n  name: string;\r\n  alias: string | undefined;\r\n}\r\n\r\nexport interface ExceptBody {\r\n  error: NameAlias;\r\n  body: AstNode[];\r\n}\r\n\r\nexport interface FuncDefNode {\r\n  params: string[];\r\n  funcAst: AstBlock;\r\n}\r\n\r\nexport interface IsNullCoelsing {\r\n  nullCoelsing: boolean | undefined;\r\n}\r\n\r\nexport interface ObjectPropertyInfo {\r\n  name: AstNode;\r\n  value: AstNode;\r\n}\r\n\r\nexport abstract class AstNode {\r\n  loc: Uint16Array | undefined = undefined;\r\n  constructor(public type: AstNodeType) {}\r\n}\r\n\r\nexport class AssignNode extends AstNode {\r\n  constructor(public target: AstNode, public source: AstNode, public loc: Uint16Array) {\r\n    super('assign');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ConstNode extends AstNode {\r\n  public value: number | string | boolean | null;\r\n\r\n  constructor(token: Token) {\r\n    super('const');\r\n    this.value = getTokenValue(token);\r\n    this.loc = getTokenLoc(token);\r\n  }\r\n}\r\n\r\nexport class CommentNode extends AstNode {\r\n  constructor(public comment: string, public loc: Uint16Array) {\r\n    super('comment');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ReturnNode extends AstNode {\r\n  constructor(public returnValue: AstNode | undefined = undefined, public loc: Uint16Array) {\r\n    super('return');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class RaiseNode extends AstNode {\r\n  constructor(public errorName: string, public errorMessageAst: AstNode, public loc: Uint16Array) {\r\n    super('raise');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ContinueNode extends AstNode {\r\n  constructor() {\r\n    super('continue');\r\n  }\r\n}\r\n\r\nexport class BreakNode extends AstNode {\r\n  constructor() {\r\n    super('break');\r\n  }\r\n}\r\n\r\nexport class SetSingleVarNode extends AstNode {\r\n  public name: string;\r\n  constructor(token: Token) {\r\n    super('setSingleVar');\r\n    this.name = token[0] as string;\r\n    this.loc = getTokenLoc(token);\r\n  }\r\n}\r\n\r\nexport class FunctionCallNode extends AstNode implements IsNullCoelsing {\r\n  public nullCoelsing: boolean | undefined = undefined;\r\n\r\n  constructor(public name: string, public paramNodes: AstNode[] | null, public loc: Uint16Array) {\r\n    super('funcCall');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class FunctionDefNode extends AstNode implements FuncDefNode {\r\n  constructor(\r\n    public funcAst: AstBlock,\r\n    public params: string[],\r\n    public isAsync: boolean,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('funcDef');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ArrowFuncDefNode extends AstNode implements FuncDefNode {\r\n  constructor(public funcAst: AstBlock, public params: string[], public loc: Uint16Array) {\r\n    super('arrowFuncDef');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ElifNode extends AstNode {\r\n  constructor(\r\n    public conditionNode: AstNode,\r\n    public elifBody: AstNode[],\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('elif');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class IfNode extends AstNode {\r\n  constructor(\r\n    public conditionNode: AstNode,\r\n    public ifBody: AstNode[],\r\n    public elifs: ElifNode[] | undefined = undefined,\r\n    public elseBody: AstNode[] | undefined = undefined,\r\n    public loc: Uint16Array,\r\n  ) {\r\n    super('if');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class TryExceptNode extends AstNode {\r\n  constructor(\r\n    public tryBody: AstNode[],\r\n    public exepts: ExceptBody[],\r\n    public elseBody: AstNode[] | undefined,\r\n    public finallyBody: AstNode[] | undefined,\r\n\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('tryExcept');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ForNode extends AstNode {\r\n  constructor(\r\n    public sourceArray: AstNode,\r\n    public itemVarName: string,\r\n    public body: AstNode[],\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('for');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class WhileNode extends AstNode {\r\n  constructor(public condition: AstNode, public body: AstNode[], public loc: Uint16Array) {\r\n    super('while');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ImportNode extends AstNode {\r\n  constructor(\r\n    public module: NameAlias,\r\n    public body: AstBlock,\r\n    public parts: NameAlias[] | undefined = undefined,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('import');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class GetSingleVarNode extends AstNode implements IsNullCoelsing {\r\n  name: string;\r\n  nullCoelsing: boolean | undefined = undefined;\r\n\r\n  constructor(token: Token, nullCoelsing: boolean | undefined = undefined) {\r\n    super('getSingleVar');\r\n    this.name = token[0] as string;\r\n    this.nullCoelsing = nullCoelsing;\r\n    this.loc = getTokenLoc(token);\r\n  }\r\n}\r\n\r\nexport class ChainingCallsNode extends AstNode {\r\n  constructor(public innerNodes: AstNode[], public loc: Uint16Array) {\r\n    super('chainingCalls');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class CreateObjectNode extends AstNode {\r\n  constructor(public props: ObjectPropertyInfo[], public loc: Uint16Array) {\r\n    super('createObject');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class CreateArrayNode extends AstNode {\r\n  constructor(public items: AstNode[], public loc: Uint16Array) {\r\n    super('createArray');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ChainingObjectAccessNode extends AstNode {\r\n  constructor(\r\n    public indexerBody: AstNode,\r\n    public nullCoelsing: boolean | undefined = undefined,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('chainingObjectAccess');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport interface LogicalNodeItem {\r\n  node: AstNode;\r\n  op: LogicalOperators | undefined;\r\n}\r\n\r\nexport class LogicalOpNode extends AstNode {\r\n  constructor(public items: LogicalNodeItem[], public loc: Uint16Array) {\r\n    super('logicalOp');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class BinOpNode extends AstNode {\r\n  constructor(\r\n    public left: AstNode,\r\n    public op: ExpressionOperators,\r\n    public right: AstNode,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('binOp');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport interface AstBlock {\r\n  name: string;\r\n  type: 'module' | 'func' | 'if' | 'for' | 'while' | 'trycatch';\r\n  funcs: FunctionDefNode[];\r\n  body: AstNode[];\r\n}\r\n","export interface CancellationToken {\r\n  cancel?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport interface BlockContext {\r\n  moduleName: string;\r\n  blockScope: Scope;\r\n  cancellationToken: CancellationToken;\r\n  returnCalled?: boolean;\r\n  breakCalled?: boolean;\r\n  continueCalled?: boolean;\r\n  returnObject?: unknown;\r\n}\r\n\r\nexport function cloneContext(context: BlockContext): BlockContext {\r\n  return {\r\n    moduleName: context.moduleName,\r\n    blockScope: context.blockScope.clone(),\r\n    // this instance should never change. Otherwise cancel won't work\r\n    cancellationToken: context.cancellationToken\r\n  } as BlockContext;\r\n}\r\n\r\nexport class Scope {\r\n  private readonly scope: Record<string, unknown> = {};\r\n\r\n  constructor(initialScope: Record<string, unknown>) {\r\n    this.scope = { ...initialScope };\r\n  }\r\n\r\n  getScope(): Record<string, unknown> {\r\n    return this.scope;\r\n  }\r\n\r\n  clone(): Scope {\r\n    return new Scope(this.scope);\r\n  }\r\n  set(key: string, value: unknown): void {\r\n    this.scope[key] = value;\r\n  }\r\n\r\n  get(key: string): unknown {\r\n    return this.scope[key];\r\n  }\r\n}\r\n","import {\r\n  ArrowFuncDefNode,\r\n  AssignNode,\r\n  AstBlock,\r\n  AstNode,\r\n  BinOpNode,\r\n  ChainingCallsNode,\r\n  ChainingObjectAccessNode,\r\n  ConstNode,\r\n  CreateArrayNode,\r\n  CreateObjectNode,\r\n  ForNode,\r\n  FuncDefNode,\r\n  FunctionCallNode,\r\n  FunctionDefNode,\r\n  GetSingleVarNode,\r\n  IfNode,\r\n  IsNullCoelsing,\r\n  LogicalOpNode,\r\n  OperationFuncs,\r\n  Primitive,\r\n  RaiseNode,\r\n  ReturnNode,\r\n  SetSingleVarNode,\r\n  TryExceptNode,\r\n  WhileNode\r\n} from '../common';\r\nimport { JspyError, JspyEvalError } from '../common/utils';\r\nimport { BlockContext, cloneContext } from './scope';\r\n\r\nexport class Evaluator {\r\n  evalBlock(ast: AstBlock, blockContext: BlockContext): unknown {\r\n    let lastResult = null;\r\n\r\n    for (const node of ast?.funcs || []) {\r\n      const funcDef = node as FunctionDefNode;\r\n\r\n      // a child scope needs to be created here\r\n      const newScope = blockContext.blockScope;\r\n\r\n      newScope.set(funcDef.funcAst.name, (...args: unknown[]): unknown =>\r\n        this.jspyFuncInvoker(funcDef, blockContext, ...args)\r\n      );\r\n    }\r\n\r\n    for (let i = 0; i < ast.body.length; i++) {\r\n      const node = ast.body[i];\r\n      if (blockContext.cancellationToken.cancel) {\r\n        const loc = node.loc || [];\r\n\r\n        if (!blockContext.cancellationToken.message) {\r\n          blockContext.cancellationToken.message = `Cancelled. ${blockContext.moduleName}: ${loc[0]}, ${loc[1]}`;\r\n        }\r\n\r\n        return blockContext.cancellationToken.message;\r\n      }\r\n\r\n      if (node.type === 'comment') {\r\n        continue;\r\n      }\r\n      if (node.type === 'import') {\r\n        // we can't use it here, because loader has to be promise\r\n        throw new Error(`Import is not support with 'eval'. Use method 'evalAsync' instead`);\r\n      }\r\n      try {\r\n        lastResult = this.evalNode(node, blockContext);\r\n\r\n        if (blockContext.returnCalled) {\r\n          const res = blockContext.returnObject;\r\n\r\n          // stop processing return\r\n          if (ast.type == 'func' || ast.type == 'module') {\r\n            blockContext.returnCalled = false;\r\n            blockContext.returnObject = null;\r\n          }\r\n          return res;\r\n        }\r\n\r\n        if (blockContext.continueCalled) {\r\n          break;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      } catch (err) {\r\n        const loc = node.loc ? node.loc : [0, 0];\r\n        if (err instanceof JspyError) {\r\n          throw err;\r\n        } else if (err instanceof JspyEvalError) {\r\n          throw err;\r\n        } else {\r\n          throw new JspyEvalError(\r\n            blockContext.moduleName,\r\n            loc[0],\r\n            loc[1],\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            (err as any).message || err\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return lastResult;\r\n  }\r\n\r\n  jspyFuncInvoker(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): unknown {\r\n    const ast = Object.assign({}, funcDef.funcAst);\r\n    ast.type = 'func';\r\n\r\n    const blockContext = cloneContext(context);\r\n\r\n    // set parameters into new scope, based incomming arguments\r\n    for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n      const argValue = args?.length > i ? args[i] : null;\r\n      blockContext.blockScope.set(funcDef.params[i], argValue);\r\n    }\r\n\r\n    return this.evalBlock(ast, blockContext);\r\n  }\r\n\r\n  private invokeFunction(\r\n    func: (...args: unknown[]) => unknown,\r\n    fps: unknown[],\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    loc: { moduleName: string; line: number; column: number }\r\n  ): unknown {\r\n    return func(...fps);\r\n  }\r\n\r\n  private evalNode(node: AstNode, blockContext: BlockContext): unknown {\r\n    if (node.type === 'import') {\r\n      // skip this for now. As modules are implemented externally\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'comment') {\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'if') {\r\n      const ifNode = node as IfNode;\r\n      let doElse = true;\r\n      if (this.evalNode(ifNode.conditionNode, blockContext)) {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock,\r\n          blockContext\r\n        );\r\n        doElse = false;\r\n      } else if (ifNode.elifs?.length) {\r\n        for (let i = 0; i < ifNode.elifs.length; i++) {\r\n          const elIfNode = ifNode.elifs[i];\r\n\r\n          if (this.evalNode(elIfNode.conditionNode, blockContext)) {\r\n            this.evalBlock(\r\n              { name: blockContext.moduleName, type: 'if', body: elIfNode.elifBody } as AstBlock,\r\n              blockContext\r\n            );\r\n            doElse = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (doElse && ifNode.elseBody) {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock,\r\n          blockContext\r\n        );\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'raise') {\r\n      const raiseNode = node as RaiseNode;\r\n      const errorMessage = this.evalNode(raiseNode.errorMessageAst, blockContext) as string;\r\n      const err = new JspyError(\r\n        blockContext.moduleName,\r\n        raiseNode.loc[0],\r\n        raiseNode.loc[1],\r\n        raiseNode.errorName,\r\n        errorMessage\r\n      );\r\n      throw err;\r\n    }\r\n\r\n    if (node.type === 'tryExcept') {\r\n      const tryNode = node as TryExceptNode;\r\n      try {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (tryNode.elseBody?.length || 0 > 0) {\r\n          this.evalBlock(\r\n            { name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      } catch (err) {\r\n        const name = err instanceof JspyError ? (err as JspyError).name : typeof err;\r\n        const message =\r\n          err instanceof JspyError\r\n            ? (err as JspyError).message\r\n            : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n              (err as any)?.message ?? String(err);\r\n        const moduleName = err instanceof JspyError ? (err as JspyError).module : 0;\r\n        const line = err instanceof JspyError ? (err as JspyError).line : 0;\r\n        const column = err instanceof JspyError ? (err as JspyError).column : 0;\r\n\r\n        const firstExept = tryNode.exepts[0];\r\n        const catchBody = firstExept.body;\r\n        const ctx = blockContext; // cloneContext(blockContext);\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', {\r\n          name,\r\n          message,\r\n          line,\r\n          column,\r\n          moduleName\r\n        });\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock,\r\n          ctx\r\n        );\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', null);\r\n      } finally {\r\n        if (tryNode.finallyBody?.length || 0 > 0) {\r\n          this.evalBlock(\r\n            {\r\n              name: blockContext.moduleName,\r\n              type: 'trycatch',\r\n              body: tryNode.finallyBody\r\n            } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'return') {\r\n      const returnNode = node as ReturnNode;\r\n      blockContext.returnCalled = true;\r\n      blockContext.returnObject = returnNode.returnValue\r\n        ? this.evalNode(returnNode.returnValue, blockContext)\r\n        : null;\r\n\r\n      return blockContext.returnObject;\r\n    }\r\n\r\n    if (node.type === 'continue') {\r\n      blockContext.continueCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'break') {\r\n      blockContext.breakCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'for') {\r\n      const forNode = node as ForNode;\r\n\r\n      const array = this.evalNode(forNode.sourceArray, blockContext) as unknown[] | string;\r\n\r\n      for (let i = 0; i < array.length; i++) {\r\n        const item = array[i];\r\n\r\n        blockContext.blockScope.set(forNode.itemVarName, item);\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'while') {\r\n      const whileNode = node as WhileNode;\r\n\r\n      while (this.evalNode(whileNode.condition, blockContext)) {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'const') {\r\n      return (node as ConstNode).value;\r\n    }\r\n\r\n    if (node.type === 'getSingleVar') {\r\n      const name = (node as GetSingleVarNode).name;\r\n\r\n      const value = blockContext.blockScope.get((node as GetSingleVarNode).name);\r\n      if (value === undefined) {\r\n        if (name.charAt(name.length - 1) === ';') {\r\n          throw new Error(`Unexpected ';' in the end.`);\r\n        } else {\r\n          throw new Error(`Variable '${name}' is not defined.`);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    if (node.type === 'binOp') {\r\n      const binOpNode = node as BinOpNode;\r\n      const left = this.evalNode(binOpNode.left, blockContext);\r\n      const right = this.evalNode(binOpNode.right, blockContext);\r\n      const func = OperationFuncs.get(binOpNode.op);\r\n      if (typeof func === 'function') return func(left as Primitive, right as Primitive);\r\n      else throw new Error('Unknown binary oprastion');\r\n    }\r\n\r\n    if (node.type === 'logicalOp') {\r\n      const logicalGroups = node as LogicalOpNode;\r\n      let ind = 0;\r\n      let gResult: unknown = true;\r\n\r\n      while (ind < logicalGroups.items.length) {\r\n        const eg = logicalGroups.items[ind++];\r\n\r\n        gResult = this.evalNode(eg.node, blockContext);\r\n\r\n        if (eg.op === 'and' && !gResult) {\r\n          return false;\r\n        }\r\n        if (eg.op === 'or' && gResult) {\r\n          return gResult;\r\n        }\r\n      }\r\n\r\n      return gResult;\r\n    }\r\n\r\n    if (node.type === 'arrowFuncDef') {\r\n      const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n      return (...args: unknown[]): unknown =>\r\n        this.jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n    }\r\n\r\n    if (node.type === 'funcCall') {\r\n      const funcCallNode = node as FunctionCallNode;\r\n      const func = blockContext.blockScope.get(funcCallNode.name) as (\r\n        ...args: unknown[]\r\n      ) => unknown;\r\n      if (typeof func !== 'function') {\r\n        throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n      }\r\n\r\n      const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || [];\r\n\r\n      return this.invokeFunction(func, pms, {\r\n        moduleName: blockContext.moduleName,\r\n        line: funcCallNode.loc[0],\r\n        column: funcCallNode.loc[1]\r\n      });\r\n    }\r\n\r\n    if (node.type === 'assign') {\r\n      const assignNode = node as AssignNode;\r\n\r\n      if (assignNode.target.type === 'getSingleVar') {\r\n        const node = assignNode.target as SetSingleVarNode;\r\n        blockContext.blockScope.set(node.name, this.evalNode(assignNode.source, blockContext));\r\n      } else if (assignNode.target.type === 'chainingCalls') {\r\n        const targetNode = assignNode.target as ChainingCallsNode;\r\n\r\n        // create a node for all but last property token\r\n        // potentially it can go to parser\r\n        const targetObjectNode = new ChainingCallsNode(\r\n          targetNode.innerNodes.slice(0, targetNode.innerNodes.length - 1),\r\n          targetNode.loc\r\n        );\r\n        const targetObject = this.evalNode(targetObjectNode, blockContext) as Record<\r\n          string,\r\n          unknown\r\n        >;\r\n\r\n        const lastInnerNode = targetNode.innerNodes[targetNode.innerNodes.length - 1];\r\n\r\n        let lastPropertyName = '';\r\n        if (lastInnerNode.type === 'getSingleVar') {\r\n          lastPropertyName = (lastInnerNode as GetSingleVarNode).name;\r\n        } else if (lastInnerNode.type === 'chainingObjectAccess') {\r\n          lastPropertyName = this.evalNode(\r\n            (lastInnerNode as ChainingObjectAccessNode).indexerBody,\r\n            blockContext\r\n          ) as string;\r\n        } else {\r\n          throw Error('Not implemented Assign operation with chaining calls');\r\n        }\r\n\r\n        targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'chainingCalls') {\r\n      return this.resolveChainingCallsNode(node as ChainingCallsNode, blockContext);\r\n    }\r\n\r\n    if (node.type === 'createObject') {\r\n      const createObjectNode = node as CreateObjectNode;\r\n      const obj = {} as Record<string, unknown>;\r\n\r\n      for (const p of createObjectNode.props) {\r\n        obj[this.evalNode(p.name, blockContext) as string] = this.evalNode(p.value, blockContext);\r\n      }\r\n\r\n      return obj;\r\n    }\r\n\r\n    if (node.type === 'createArray') {\r\n      const arrayNode = node as CreateArrayNode;\r\n      const res = [] as unknown[];\r\n\r\n      for (const item of arrayNode.items) {\r\n        res.push(this.evalNode(item, blockContext));\r\n      }\r\n\r\n      return res;\r\n    }\r\n  }\r\n\r\n  private resolveChainingCallsNode(chNode: ChainingCallsNode, blockContext: BlockContext): unknown {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let startObject = this.evalNode(chNode.innerNodes[0], blockContext) as any;\r\n\r\n    for (let i = 1; i < chNode.innerNodes.length; i++) {\r\n      const nestedProp = chNode.innerNodes[i];\r\n\r\n      if ((chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n        startObject = {};\r\n      }\r\n\r\n      if (nestedProp.type === 'getSingleVar') {\r\n        startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n      } else if (nestedProp.type === 'chainingObjectAccess') {\r\n        const node = nestedProp as ChainingObjectAccessNode;\r\n        // startObject = startObject[node.] as unknown;\r\n        startObject = startObject[\r\n          this.evalNode(node.indexerBody, blockContext) as string\r\n        ] as unknown;\r\n      } else if (nestedProp.type === 'funcCall') {\r\n        const funcCallNode = nestedProp as FunctionCallNode;\r\n        const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n        if (\r\n          (func === undefined || func === null) &&\r\n          (chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing\r\n        ) {\r\n          startObject = null;\r\n          continue;\r\n        }\r\n\r\n        if (typeof func !== 'function') {\r\n          throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n        }\r\n        const pms = [];\r\n        for (const p of funcCallNode.paramNodes || []) {\r\n          pms.push(this.evalNode(p, blockContext));\r\n        }\r\n\r\n        startObject = this.invokeFunction(func.bind(startObject), pms, {\r\n          moduleName: blockContext.moduleName,\r\n          line: funcCallNode.loc[0],\r\n          column: funcCallNode.loc[0]\r\n        });\r\n      } else {\r\n        throw Error(\"Can't resolve chainingCalls node\");\r\n      }\r\n    }\r\n\r\n    return startObject === undefined ? null : startObject;\r\n  }\r\n}\r\n","import {\r\n  ArrowFuncDefNode,\r\n  AssignNode,\r\n  AstBlock,\r\n  AstNode,\r\n  BinOpNode,\r\n  ChainingCallsNode,\r\n  ChainingObjectAccessNode,\r\n  ConstNode,\r\n  CreateArrayNode,\r\n  CreateObjectNode,\r\n  ForNode,\r\n  FuncDefNode,\r\n  FunctionCallNode,\r\n  FunctionDefNode,\r\n  GetSingleVarNode,\r\n  IfNode,\r\n  ImportNode,\r\n  IsNullCoelsing,\r\n  LogicalOpNode,\r\n  OperationFuncs,\r\n  Primitive,\r\n  RaiseNode,\r\n  ReturnNode,\r\n  SetSingleVarNode,\r\n  TryExceptNode,\r\n  WhileNode\r\n} from '../common';\r\nimport { JspyEvalError, JspyError, getImportType } from '../common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { BlockContext, cloneContext } from './scope';\r\n\r\n/**\r\n * This is copy/paste from Evaluator.\r\n * Sadly, we have to copy code around to support both async and non async methods.\r\n * So, any changes to this method, should be replicated in the evaluator.ts\r\n */\r\nexport class EvaluatorAsync {\r\n  private moduleParser: (modulePath: string) => Promise<AstBlock> = () =>\r\n    Promise.reject('Module parser is not registered!');\r\n  private jsonFileLoader: (jsonFilePath: string) => Promise<string> = () => Promise.reject('{}');\r\n  private blockContextFactory?: (modulePath: string, ast: AstBlock) => BlockContext;\r\n\r\n  registerModuleParser(moduleParser: (modulePath: string) => Promise<AstBlock>): EvaluatorAsync {\r\n    this.moduleParser = moduleParser;\r\n    return this;\r\n  }\r\n\r\n  registerJsonFileLoader(jsonFileLoader: (modulePath: string) => Promise<string>): EvaluatorAsync {\r\n    this.jsonFileLoader = jsonFileLoader;\r\n    return this;\r\n  }\r\n\r\n  registerBlockContextFactory(\r\n    blockContextFactory: (modulePath: string, ast: AstBlock) => BlockContext\r\n  ): EvaluatorAsync {\r\n    this.blockContextFactory = blockContextFactory;\r\n    return this;\r\n  }\r\n\r\n  async evalBlockAsync(ast: AstBlock, blockContext: BlockContext): Promise<unknown> {\r\n    let lastResult = null;\r\n\r\n    for (const node of ast?.funcs || []) {\r\n      const funcDef = node as FunctionDefNode;\r\n\r\n      // a child scope needs to be created here\r\n      const newScope = blockContext.blockScope;\r\n\r\n      const invoker = funcDef.isAsync\r\n        ? async (...args: unknown[]): Promise<unknown> =>\r\n            await this.jspyFuncInvokerAsync(funcDef, blockContext, ...args)\r\n        : (...args: unknown[]): unknown =>\r\n            new Evaluator().jspyFuncInvoker(funcDef, blockContext, ...args);\r\n\r\n      newScope.set(funcDef.funcAst.name, invoker);\r\n    }\r\n\r\n    for (let i = 0; i < ast.body.length; i++) {\r\n      const node = ast.body[i];\r\n      if (blockContext.cancellationToken.cancel) {\r\n        const loc = node.loc || [];\r\n\r\n        if (!blockContext.cancellationToken.message) {\r\n          blockContext.cancellationToken.message = `Cancelled. ${blockContext.moduleName}: ${loc[0]}, ${loc[1]}`;\r\n        }\r\n\r\n        return blockContext.cancellationToken.message;\r\n      }\r\n\r\n      if (node.type === 'comment') {\r\n        continue;\r\n      }\r\n      if (node.type === 'import') {\r\n        const importNode = node as ImportNode;\r\n        const iType = getImportType(importNode.module.name);\r\n\r\n        if (iType === 'json') {\r\n          const jsonValue = JSON.parse(await this.jsonFileLoader(importNode.module.name));\r\n          blockContext.blockScope.set(\r\n            importNode.module.alias || this.defaultModuleName(importNode.module.name),\r\n            jsonValue\r\n          );\r\n          continue;\r\n        } else if (iType !== 'jspyModule') {\r\n          // it is not JSPY import. It is JS and should be handled externally\r\n          continue;\r\n        }\r\n\r\n        if (typeof this.blockContextFactory !== 'function') {\r\n          throw new Error('blockContextFactory is not initialized');\r\n        }\r\n\r\n        const moduleAst = await this.moduleParser(importNode.module.name);\r\n        const moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);\r\n        await this.evalBlockAsync(moduleAst, moduleBlockContext);\r\n\r\n        let scope = blockContext.blockScope.getScope();\r\n\r\n        if (!importNode.parts?.length) {\r\n          // if no parts, then we need to assign to a separate object\r\n          scope = {};\r\n          blockContext.blockScope.set(\r\n            importNode.module.alias || this.defaultModuleName(importNode.module.name),\r\n            scope\r\n          );\r\n        }\r\n\r\n        this.assignFunctionsToScope(\r\n          scope,\r\n          moduleBlockContext,\r\n          moduleAst,\r\n          importNode.parts?.map(p => p.name)\r\n        );\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        lastResult = await this.evalNodeAsync(node, blockContext);\r\n        if (blockContext.returnCalled) {\r\n          const res = blockContext.returnObject;\r\n          // stop processing return\r\n          if (ast.type == 'func' || ast.type == 'module') {\r\n            blockContext.returnCalled = false;\r\n            blockContext.returnObject = null;\r\n          }\r\n          return res;\r\n        }\r\n\r\n        if (blockContext.continueCalled) {\r\n          break;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      } catch (err) {\r\n        const loc = node.loc ? node.loc : [0, 0];\r\n        if (err instanceof JspyError) {\r\n          throw err;\r\n        } else if (err instanceof JspyEvalError) {\r\n          throw err;\r\n        } else {\r\n          throw new JspyEvalError(\r\n            blockContext.moduleName,\r\n            loc[0],\r\n            loc[1],\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            (err as any).message || err\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return lastResult;\r\n  }\r\n\r\n  private assignFunctionsToScope(\r\n    scope: Record<string, unknown>,\r\n    moduleBlockContext: BlockContext,\r\n    moduleAst: AstBlock,\r\n    parts?: string[]\r\n  ): void {\r\n    const funcs = moduleAst.funcs.filter(f => !parts || parts.indexOf(f.funcAst?.name) >= 0);\r\n\r\n    for (let i = 0; i < funcs.length; i++) {\r\n      const funcDef = funcs[i] as FunctionDefNode;\r\n\r\n      const invoker = funcDef.isAsync\r\n        ? async (...args: unknown[]): Promise<unknown> =>\r\n            await this.jspyFuncInvokerAsync(funcDef, moduleBlockContext, ...args)\r\n        : (...args: unknown[]): unknown =>\r\n            new Evaluator().jspyFuncInvoker(funcDef, moduleBlockContext, ...args);\r\n\r\n      scope[funcDef.funcAst.name] = invoker;\r\n    }\r\n  }\r\n\r\n  private defaultModuleName(name: string): string {\r\n    return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'));\r\n  }\r\n\r\n  private async jspyFuncInvokerAsync(\r\n    funcDef: FuncDefNode,\r\n    context: BlockContext,\r\n    ...args: unknown[]\r\n  ): Promise<unknown> {\r\n    const ast = Object.assign({}, funcDef.funcAst);\r\n    ast.type = 'func';\r\n\r\n    const blockContext = cloneContext(context);\r\n\r\n    // set parameters into new scope, based incomming arguments\r\n    for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n      const argValue = args?.length > i ? args[i] : null;\r\n      blockContext.blockScope.set(funcDef.params[i], argValue);\r\n    }\r\n\r\n    return await this.evalBlockAsync(ast, blockContext);\r\n  }\r\n\r\n  private async invokeFunctionAsync(\r\n    func: (...args: unknown[]) => unknown,\r\n    fps: unknown[],\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    loc?: { moduleName: string; line: number; column: number }\r\n  ): Promise<unknown> {\r\n    return await func(...fps);\r\n  }\r\n\r\n  private async evalNodeAsync(node: AstNode, blockContext: BlockContext): Promise<unknown> {\r\n    if (node.type === 'import') {\r\n      throw new Error('Import should be defined at the start');\r\n    }\r\n\r\n    if (node.type === 'comment') {\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'if') {\r\n      const ifNode = node as IfNode;\r\n      let doElse = true;\r\n\r\n      if (await this.evalNodeAsync(ifNode.conditionNode, blockContext)) {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock,\r\n          blockContext\r\n        );\r\n        doElse = false;\r\n      } else if (ifNode.elifs?.length) {\r\n        for (let i = 0; i < ifNode.elifs.length; i++) {\r\n          const elIfNode = ifNode.elifs[i];\r\n\r\n          if (await this.evalNodeAsync(elIfNode.conditionNode, blockContext)) {\r\n            await this.evalBlockAsync(\r\n              { name: blockContext.moduleName, type: 'if', body: elIfNode.elifBody } as AstBlock,\r\n              blockContext\r\n            );\r\n            doElse = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (doElse && ifNode.elseBody) {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock,\r\n          blockContext\r\n        );\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'raise') {\r\n      const raiseNode = node as RaiseNode;\r\n      const errorMessage = (await this.evalNodeAsync(\r\n        raiseNode.errorMessageAst,\r\n        blockContext\r\n      )) as string;\r\n      const err = new JspyError(\r\n        blockContext.moduleName,\r\n        raiseNode.loc[0],\r\n        raiseNode.loc[1],\r\n        raiseNode.errorName,\r\n        errorMessage\r\n      );\r\n      throw err;\r\n    }\r\n\r\n    if (node.type === 'tryExcept') {\r\n      const tryNode = node as TryExceptNode;\r\n      try {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (tryNode.elseBody?.length || 0 > 0) {\r\n          await this.evalBlockAsync(\r\n            { name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      } catch (err) {\r\n        // catches here all exceptions. Including JSPY Eval errors\r\n        const name = err instanceof JspyError ? (err as JspyError).name : typeof err;\r\n        const message =\r\n          err instanceof JspyError\r\n            ? (err as JspyError).message\r\n            : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n              (err as any)?.message ?? String(err);\r\n        const moduleName = err instanceof JspyError ? (err as JspyError).module : 0;\r\n        const line = err instanceof JspyError ? (err as JspyError).line : 0;\r\n        const column = err instanceof JspyError ? (err as JspyError).column : 0;\r\n\r\n        const firstExept = tryNode.exepts[0];\r\n        const catchBody = firstExept.body;\r\n        const ctx = blockContext;\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', {\r\n          name,\r\n          message,\r\n          line,\r\n          column,\r\n          moduleName\r\n        });\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock,\r\n          ctx\r\n        );\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', null);\r\n      } finally {\r\n        if (tryNode.finallyBody?.length || 0 > 0) {\r\n          await this.evalBlockAsync(\r\n            {\r\n              name: blockContext.moduleName,\r\n              type: 'trycatch',\r\n              body: tryNode.finallyBody\r\n            } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'return') {\r\n      const returnNode = node as ReturnNode;\r\n      blockContext.returnCalled = true;\r\n      blockContext.returnObject = returnNode.returnValue\r\n        ? await this.evalNodeAsync(returnNode.returnValue, blockContext)\r\n        : null;\r\n\r\n      return blockContext.returnObject;\r\n    }\r\n\r\n    if (node.type === 'continue') {\r\n      blockContext.continueCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'break') {\r\n      blockContext.breakCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'for') {\r\n      const forNode = node as ForNode;\r\n\r\n      const array = (await this.evalNodeAsync(forNode.sourceArray, blockContext)) as\r\n        | unknown[]\r\n        | string;\r\n      for (let i = 0; i < array.length; i++) {\r\n        const item = array[i];\r\n        blockContext.blockScope.set(forNode.itemVarName, item);\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'while') {\r\n      const whileNode = node as WhileNode;\r\n\r\n      while (await this.evalNodeAsync(whileNode.condition, blockContext)) {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'const') {\r\n      return (node as ConstNode).value;\r\n    }\r\n\r\n    if (node.type === 'getSingleVar') {\r\n      const name = (node as GetSingleVarNode).name;\r\n      const value = blockContext.blockScope.get(name);\r\n\r\n      if (value === undefined) {\r\n        if (name.charAt(name.length - 1) === ';') {\r\n          throw new Error(`Unexpected ';' in the end.`);\r\n        } else {\r\n          throw new Error(`Variable '${name}' is not defined.`);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    if (node.type === 'binOp') {\r\n      const binOpNode = node as BinOpNode;\r\n      const left = await this.evalNodeAsync(binOpNode.left, blockContext);\r\n      const right = await this.evalNodeAsync(binOpNode.right, blockContext);\r\n\r\n      const func = OperationFuncs.get(binOpNode.op);\r\n      if (typeof func === 'function') return func(left as Primitive, right as Primitive);\r\n      else throw new Error('Unknown binary oprastion');\r\n    }\r\n\r\n    if (node.type === 'logicalOp') {\r\n      const logicalGroups = node as LogicalOpNode;\r\n      let ind = 0;\r\n      let gResult: unknown = true;\r\n\r\n      while (ind < logicalGroups.items.length) {\r\n        const eg = logicalGroups.items[ind++];\r\n\r\n        gResult = await this.evalNodeAsync(eg.node, blockContext);\r\n\r\n        if (eg.op === 'and' && !gResult) {\r\n          return false;\r\n        }\r\n        if (eg.op === 'or' && gResult) {\r\n          return gResult;\r\n        }\r\n      }\r\n\r\n      return gResult;\r\n    }\r\n\r\n    if (node.type === 'arrowFuncDef') {\r\n      const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n      return (...args: unknown[]): unknown =>\r\n        new Evaluator().jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n    }\r\n\r\n    if (node.type === 'funcCall') {\r\n      const funcCallNode = node as FunctionCallNode;\r\n      const func = blockContext.blockScope.get(funcCallNode.name) as (\r\n        ...args: unknown[]\r\n      ) => unknown;\r\n\r\n      if (typeof func !== 'function') {\r\n        throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n      }\r\n\r\n      const pms = [];\r\n      for (const p of funcCallNode.paramNodes || []) {\r\n        pms.push(await this.evalNodeAsync(p, blockContext));\r\n      }\r\n\r\n      return await this.invokeFunctionAsync(func, pms, {\r\n        moduleName: blockContext.moduleName,\r\n        line: funcCallNode.loc[0],\r\n        column: funcCallNode.loc[0]\r\n      });\r\n    }\r\n\r\n    if (node.type === 'assign') {\r\n      const assignNode = node as AssignNode;\r\n\r\n      if (assignNode.target.type === 'getSingleVar') {\r\n        const node = assignNode.target as SetSingleVarNode;\r\n        blockContext.blockScope.set(\r\n          node.name,\r\n          await this.evalNodeAsync(assignNode.source, blockContext)\r\n        );\r\n      } else if (assignNode.target.type === 'chainingCalls') {\r\n        const targetNode = assignNode.target as ChainingCallsNode;\r\n\r\n        // create a node for all but last property token\r\n        // potentially it can go to parser\r\n        const targetObjectNode = new ChainingCallsNode(\r\n          targetNode.innerNodes.slice(0, targetNode.innerNodes.length - 1),\r\n          targetNode.loc\r\n        );\r\n        const targetObject = (await this.evalNodeAsync(targetObjectNode, blockContext)) as Record<\r\n          string,\r\n          unknown\r\n        >;\r\n\r\n        const lastInnerNode = targetNode.innerNodes[targetNode.innerNodes.length - 1];\r\n\r\n        let lastPropertyName = '';\r\n        if (lastInnerNode.type === 'getSingleVar') {\r\n          lastPropertyName = (lastInnerNode as GetSingleVarNode).name;\r\n        } else if (lastInnerNode.type === 'chainingObjectAccess') {\r\n          lastPropertyName = (await this.evalNodeAsync(\r\n            (lastInnerNode as ChainingObjectAccessNode).indexerBody,\r\n            blockContext\r\n          )) as string;\r\n        } else {\r\n          throw Error('Not implemented Assign operation with chaining calls');\r\n        }\r\n\r\n        targetObject[lastPropertyName] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'chainingCalls') {\r\n      return await this.resolveChainingCallsNode(node as ChainingCallsNode, blockContext);\r\n    }\r\n\r\n    if (node.type === 'createObject') {\r\n      const createObjectNode = node as CreateObjectNode;\r\n      const obj = {} as Record<string, unknown>;\r\n\r\n      for (const p of createObjectNode.props) {\r\n        obj[(await this.evalNodeAsync(p.name, blockContext)) as string] = await this.evalNodeAsync(\r\n          p.value,\r\n          blockContext\r\n        );\r\n      }\r\n\r\n      return obj;\r\n    }\r\n\r\n    if (node.type === 'createArray') {\r\n      const arrayNode = node as CreateArrayNode;\r\n      const res = [] as unknown[];\r\n\r\n      for (const item of arrayNode.items) {\r\n        res.push(await this.evalNodeAsync(item, blockContext));\r\n      }\r\n\r\n      return res;\r\n    }\r\n  }\r\n\r\n  private async resolveChainingCallsNode(\r\n    chNode: ChainingCallsNode,\r\n    blockContext: BlockContext\r\n  ): Promise<unknown> {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let startObject = (await this.evalNodeAsync(chNode.innerNodes[0], blockContext)) as any;\r\n\r\n    for (let i = 1; i < chNode.innerNodes.length; i++) {\r\n      const nestedProp = chNode.innerNodes[i];\r\n\r\n      if ((chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n        startObject = {};\r\n      }\r\n\r\n      if (nestedProp.type === 'getSingleVar') {\r\n        startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n      } else if (nestedProp.type === 'chainingObjectAccess') {\r\n        const node = nestedProp as ChainingObjectAccessNode;\r\n        // startObject = startObject[node.] as unknown;\r\n        startObject = startObject[\r\n          (await this.evalNodeAsync(node.indexerBody, blockContext)) as string\r\n        ] as unknown;\r\n      } else if (nestedProp.type === 'funcCall') {\r\n        const funcCallNode = nestedProp as FunctionCallNode;\r\n        const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n        if (\r\n          (func === undefined || func === null) &&\r\n          (chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing\r\n        ) {\r\n          startObject = null;\r\n          continue;\r\n        }\r\n\r\n        if (typeof func !== 'function') {\r\n          throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n        }\r\n        const pms = [];\r\n        for (const p of funcCallNode.paramNodes || []) {\r\n          pms.push(await this.evalNodeAsync(p, blockContext));\r\n        }\r\n\r\n        startObject = await this.invokeFunctionAsync(func.bind(startObject), pms, {\r\n          moduleName: blockContext.moduleName,\r\n          line: funcCallNode.loc[0],\r\n          column: funcCallNode.loc[0]\r\n        });\r\n      } else {\r\n        throw Error(\"Can't resolve chainingCalls node\");\r\n      }\r\n    }\r\n\r\n    return startObject === undefined ? null : startObject;\r\n  }\r\n}\r\n","import { parseDatetimeOrNull } from './common/utils';\r\n\r\nexport const INITIAL_SCOPE = {\r\n  jsPython(): string {\r\n    return `JSPython v2.1.10 (c) 2022 FalconSoft Ltd. All rights reserved.`;\r\n  },\r\n  dateTime: (str: number | string | unknown = null): Date =>\r\n    parseDatetimeOrNull(str as string) || new Date(),\r\n  range: range,\r\n  print: (...args: unknown[]): unknown => {\r\n    console.log(...args);\r\n    return args.length > 0 ? args[0] : null;\r\n  },\r\n  isNull: (v: unknown, defValue: unknown = null): boolean | unknown =>\r\n    defValue === null ? v === null : v || defValue,\r\n  isDate: (d: unknown): boolean => d instanceof Date,\r\n  isFunction: (v: unknown): boolean => typeof v === 'function',\r\n  isString: (v: unknown): boolean => typeof v === 'string',\r\n  deleteProperty: (obj: Record<string, unknown>, propName: string): boolean => delete obj[propName],\r\n  Math: Math,\r\n  Object: Object,\r\n  Array: Array,\r\n  JSON: JSON,\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  printExecutionContext: (): void => {}, // will be overriden at runtime\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  getExecutionContext: (): Record<string, unknown> => ({}) // will be overriden at runtime\r\n};\r\n\r\n/**\r\n * This interface needs to be replaced\r\n */\r\nexport interface PackageToImport {\r\n  name: string;\r\n  properties?: { name: string; as?: string }[];\r\n  as?: string;\r\n}\r\n\r\nfunction range(start: number, stop = NaN, step = 1): number[] {\r\n  const arr: number[] = [];\r\n  const isStopNaN = isNaN(stop);\r\n  stop = isStopNaN ? start : stop;\r\n  start = isStopNaN ? 0 : start;\r\n  let i = start;\r\n  while (i < stop) {\r\n    arr.push(i);\r\n    i += step;\r\n  }\r\n  return arr;\r\n}\r\n","import {\r\n  BinOpNode,\r\n  ConstNode,\r\n  AstBlock,\r\n  Token,\r\n  AstNode,\r\n  Operators,\r\n  AssignNode,\r\n  TokenTypes,\r\n  GetSingleVarNode,\r\n  FunctionCallNode,\r\n  getTokenType,\r\n  getTokenValue,\r\n  isTokenTypeLiteral,\r\n  getStartLine,\r\n  getStartColumn,\r\n  getEndColumn,\r\n  getEndLine,\r\n  findOperators,\r\n  splitTokens,\r\n  findTokenValueIndex,\r\n  FunctionDefNode,\r\n  CreateObjectNode,\r\n  ObjectPropertyInfo,\r\n  CreateArrayNode,\r\n  ArrowFuncDefNode,\r\n  ExpressionOperators,\r\n  IfNode,\r\n  ForNode,\r\n  WhileNode,\r\n  ImportNode,\r\n  NameAlias,\r\n  ContinueNode,\r\n  BreakNode,\r\n  ReturnNode,\r\n  CommentNode,\r\n  getTokenLoc,\r\n  OperationTypes,\r\n  LogicalNodeItem,\r\n  LogicalOperators,\r\n  LogicalOpNode,\r\n  ComparisonOperators,\r\n  TryExceptNode,\r\n  ExceptBody,\r\n  RaiseNode,\r\n  findChainingCallTokensIndexes,\r\n  splitTokensByIndexes,\r\n  ChainingCallsNode,\r\n  ChainingObjectAccessNode,\r\n  ElifNode\r\n} from '../common';\r\nimport { JspyParserError } from '../common/utils';\r\n\r\nclass InstructionLine {\r\n  readonly tokens: Token[] = [];\r\n\r\n  startLine(): number {\r\n    return getStartLine(this.tokens[0]);\r\n  }\r\n\r\n  startColumn(): number {\r\n    return getStartColumn(this.tokens[0]);\r\n  }\r\n\r\n  endLine(): number {\r\n    return getEndLine(this.tokens[this.tokens.length - 1]);\r\n  }\r\n\r\n  endColumn(): number {\r\n    return getEndColumn(this.tokens[this.tokens.length - 1]);\r\n  }\r\n}\r\n\r\nexport class Parser {\r\n  private _currentToken: Token | null = null;\r\n  private _moduleName = '';\r\n\r\n  /**\r\n   * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code\r\n   * @param tokens tokens\r\n   * @param options parsing options. By default it will exclude comments and include LOC (Line of code)\r\n   */\r\n  parse(tokens: Token[], name = 'main.jspy', type = 'module'): AstBlock {\r\n    this._moduleName = name;\r\n    const ast = { name, type, funcs: [], body: [] } as AstBlock;\r\n\r\n    if (!tokens || !tokens.length) {\r\n      return ast;\r\n    }\r\n\r\n    try {\r\n      // group all tokens into an Instruction lines.\r\n      const instructions = this.tokensToInstructionLines(tokens, 1);\r\n\r\n      // process all instructions\r\n      this.instructionsToNodes(instructions, ast);\r\n    } catch (error) {\r\n      const err = error as Error;\r\n      const token = this._currentToken ?? ({} as Token);\r\n      throw new JspyParserError(\r\n        ast.name,\r\n        getStartLine(token),\r\n        getStartColumn(token),\r\n        err.message || String(err)\r\n      );\r\n    }\r\n    return ast;\r\n  }\r\n\r\n  private instructionsToNodes(instructions: InstructionLine[], ast: AstBlock): void {\r\n    const getBody = (tokens: Token[], startTokenIndex: number): AstNode[] => {\r\n      const instructionLines = this.tokensToInstructionLines(\r\n        tokens,\r\n        getStartLine(tokens[startTokenIndex])\r\n      );\r\n      const bodyAst = { name: ast.name, body: [] as AstNode[], funcs: [] as AstNode[] } as AstBlock;\r\n      this.instructionsToNodes(instructionLines, bodyAst);\r\n      return bodyAst.body;\r\n    };\r\n\r\n    const findIndexes = (tkns: Token[], operation: OperationTypes, result: number[]): boolean => {\r\n      result.splice(0, result.length);\r\n      findOperators(tkns, operation).forEach(r => result.push(r));\r\n      return !!result.length;\r\n    };\r\n\r\n    for (let i = 0; i < instructions.length; i++) {\r\n      const instruction = instructions[i];\r\n\r\n      // remove comments\r\n      let tt = 0;\r\n      while (tt < instruction.tokens.length) {\r\n        if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {\r\n          instruction.tokens.splice(tt, 1);\r\n        } else {\r\n          tt++;\r\n        }\r\n      }\r\n      if (!instruction.tokens.length) {\r\n        continue;\r\n      }\r\n\r\n      const firstToken = instruction.tokens[0];\r\n      const secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;\r\n      this._currentToken = firstToken;\r\n\r\n      const logicOpIndexes: number[] = [];\r\n      const assignTokenIndexes: number[] = [];\r\n\r\n      if (getTokenType(firstToken) === TokenTypes.Comment) {\r\n        ast.body.push(\r\n          new CommentNode(getTokenValue(firstToken) as string, getTokenLoc(firstToken))\r\n        );\r\n      } else if (\r\n        getTokenValue(firstToken) === 'def' ||\r\n        (getTokenValue(firstToken) === 'async' && getTokenValue(secondToken) === 'def')\r\n      ) {\r\n        const isAsync = getTokenValue(firstToken) === 'async';\r\n        const funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]) as string;\r\n        const paramsTokens = instruction.tokens.slice(\r\n          instruction.tokens.findIndex(tkns => getTokenValue(tkns) === '(') + 1,\r\n          instruction.tokens.findIndex(tkns => getTokenValue(tkns) === ')')\r\n        );\r\n\r\n        const params = splitTokens(paramsTokens, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for def`;\r\n        }\r\n\r\n        const instructionLines = this.tokensToInstructionLines(\r\n          instruction.tokens,\r\n          getStartLine(instruction.tokens[endDefOfDef + 1])\r\n        );\r\n        const funcAst = {\r\n          name: funcName,\r\n          body: [] as AstNode[],\r\n          funcs: [] as AstNode[]\r\n        } as AstBlock;\r\n        this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n        ast.funcs.push(\r\n          new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0]))\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'if') {\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for if`;\r\n        }\r\n\r\n        const ifBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n        const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n\r\n        const conditionNode = findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)\r\n          ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n          : this.createExpressionNode(conditionTokens);\r\n\r\n        // elifs\r\n        const elifNodes: ElifNode[] = [];\r\n        while (\r\n          instructions.length > i + 1 &&\r\n          getTokenValue(instructions[i + 1].tokens[0]) === 'elif'\r\n        ) {\r\n          const elifInstruction = instructions[++i];\r\n\r\n          const endOfElif = findTokenValueIndex(elifInstruction.tokens, v => v === ':');\r\n\r\n          const conditionTokens = elifInstruction.tokens.slice(1, endDefOfDef);\r\n\r\n          const elifConditionNode = findIndexes(\r\n            conditionTokens,\r\n            OperationTypes.Logical,\r\n            logicOpIndexes\r\n          )\r\n            ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n            : this.createExpressionNode(conditionTokens);\r\n\r\n          const elifBody = getBody(elifInstruction.tokens, endOfElif + 1);\r\n          elifNodes.push(\r\n            new ElifNode(elifConditionNode, elifBody, getTokenLoc(elifInstruction.tokens[0]))\r\n          );\r\n        }\r\n\r\n        // else\r\n        let elseBody: AstNode[] | undefined = undefined;\r\n        if (\r\n          instructions.length > i + 1 &&\r\n          getTokenValue(instructions[i + 1].tokens[0]) === 'else' &&\r\n          getTokenValue(instructions[i + 1].tokens[1]) === ':'\r\n        ) {\r\n          elseBody = getBody(instructions[i + 1].tokens, 2);\r\n          i++;\r\n        }\r\n\r\n        ast.body.push(\r\n          new IfNode(conditionNode, ifBody, elifNodes, elseBody, getTokenLoc(firstToken))\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'try') {\r\n        if (getTokenValue(instruction.tokens[1]) !== ':') {\r\n          throw `'try' statement should be followed by ':'`;\r\n        }\r\n\r\n        const tryBody = getBody(instruction.tokens, 2);\r\n        const excepts: ExceptBody[] = [];\r\n\r\n        let elseBody: AstNode[] | undefined = undefined;\r\n        let finallyBody: AstNode[] | undefined = undefined;\r\n\r\n        while (\r\n          instructions.length > i + 1 &&\r\n          (getTokenValue(instructions[i + 1].tokens[0]) === 'else' ||\r\n            getTokenValue(instructions[i + 1].tokens[0]) === 'except' ||\r\n            getTokenValue(instructions[i + 1].tokens[0]) === 'finally')\r\n        ) {\r\n          if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {\r\n            if (elseBody) {\r\n              throw new Error(`Only one 'else' is allowed in a 'try'`);\r\n            }\r\n\r\n            elseBody = getBody(instructions[i + 1].tokens, 2);\r\n          }\r\n\r\n          if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {\r\n            if (finallyBody) {\r\n              throw new Error(`Only one 'else' is allowed in a 'try'`);\r\n            }\r\n\r\n            finallyBody = getBody(instructions[i + 1].tokens, 2);\r\n          }\r\n\r\n          if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {\r\n            const endIndex = findTokenValueIndex(instructions[i + 1].tokens, v => v === ':');\r\n            const except = {} as ExceptBody;\r\n\r\n            if (endIndex === 2) {\r\n              except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) } as NameAlias;\r\n            } else if (endIndex === 3) {\r\n              except.error = {\r\n                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                alias: getTokenValue(instructions[i + 1].tokens[2])\r\n              } as NameAlias;\r\n            } else if (endIndex === 4) {\r\n              except.error = {\r\n                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                alias: getTokenValue(instructions[i + 1].tokens[3])\r\n              } as NameAlias;\r\n            } else if (endIndex !== 1) {\r\n              throw new Error(\r\n                `Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)`\r\n              );\r\n            }\r\n\r\n            except.body = getBody(instructions[i + 1].tokens, endIndex + 1);\r\n\r\n            excepts.push(except);\r\n          }\r\n\r\n          i++;\r\n        }\r\n\r\n        if (!excepts.length) {\r\n          throw new Error('Except: is missing');\r\n        }\r\n\r\n        ast.body.push(\r\n          new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken))\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'continue') {\r\n        ast.body.push(new ContinueNode());\r\n      } else if (getTokenValue(firstToken) === 'break') {\r\n        ast.body.push(new BreakNode());\r\n      } else if (getTokenValue(firstToken) === 'return') {\r\n        ast.body.push(\r\n          new ReturnNode(\r\n            instruction.tokens.length > 1\r\n              ? this.createExpressionNode(instruction.tokens.slice(1))\r\n              : undefined,\r\n            getTokenLoc(firstToken)\r\n          )\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'raise') {\r\n        if (instruction.tokens.length === 1) {\r\n          throw new Error(`Incorrect 'raise' usage. Please specify error name and message `);\r\n        }\r\n        const errorName = getTokenValue(instruction.tokens[1]) as string;\r\n\r\n        // const errorMessage =\r\n        //   instruction.tokens.length == 5 &&\r\n        //   getTokenValue(instruction.tokens[2]) === '(' &&\r\n        //   getTokenValue(instruction.tokens[4]) === ')'\r\n        //     ? (getTokenValue(instruction.tokens[3]) as string)\r\n        //     : undefined;\r\n\r\n        const errMsg = this.createExpressionNode(instruction.tokens.slice(1));\r\n\r\n        ast.body.push(new RaiseNode(errorName, errMsg, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'for') {\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for if`;\r\n        }\r\n\r\n        const itemVarName = getTokenValue(instruction.tokens[1]) as string;\r\n        const sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef));\r\n        const forBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n        ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'while') {\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for [while]`;\r\n        }\r\n\r\n        const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n        const conditionNode = findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)\r\n          ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n          : this.createExpressionNode(conditionTokens);\r\n\r\n        const body = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n        ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'import') {\r\n        let asIndex = findTokenValueIndex(instruction.tokens, v => v === 'as');\r\n        if (asIndex < 0) {\r\n          asIndex = instruction.tokens.length;\r\n        }\r\n\r\n        const module = {\r\n          name: instruction.tokens\r\n            .slice(1, asIndex)\r\n            .map(t => getTokenValue(t))\r\n            .join(''),\r\n          alias:\r\n            instruction.tokens\r\n              .slice(asIndex + 1)\r\n              .map(t => getTokenValue(t))\r\n              .join('') || undefined\r\n        } as NameAlias;\r\n\r\n        const body = {} as AstBlock; // empty for now\r\n        ast.body.push(new ImportNode(module, body, undefined, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'from') {\r\n        const importIndex = findTokenValueIndex(instruction.tokens, v => v === 'import');\r\n        if (importIndex < 0) {\r\n          throw Error(`'import' must follow 'from'`);\r\n        }\r\n\r\n        const module = {\r\n          name: instruction.tokens\r\n            .slice(1, importIndex)\r\n            .map(t => getTokenValue(t))\r\n            .join('')\r\n        } as NameAlias;\r\n\r\n        const parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',').map(t => {\r\n          return {\r\n            name: getTokenValue(t[0]),\r\n            alias: t.length === 3 ? getTokenValue(t[2]) : undefined\r\n          } as NameAlias;\r\n        });\r\n\r\n        const body = {} as AstBlock; // empty for now\r\n\r\n        ast.body.push(new ImportNode(module, body, parts, getTokenLoc(firstToken)));\r\n      } else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {\r\n        const assignTokens = splitTokens(instruction.tokens, '=');\r\n        const target = this.createExpressionNode(assignTokens[0]);\r\n        const source = this.createExpressionNode(assignTokens[1]);\r\n        ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));\r\n      } else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {\r\n        ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));\r\n      } else {\r\n        ast.body.push(this.createExpressionNode(instruction.tokens));\r\n      }\r\n    }\r\n  }\r\n\r\n  private sliceWithBrackets(a: Token[], begin: number, end: number): Token[] {\r\n    // if expression is in brackets, then we need clean brackets\r\n    if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {\r\n      begin++;\r\n      end--;\r\n    }\r\n\r\n    return a.slice(begin, end);\r\n  }\r\n\r\n  private groupComparisonOperations(indexes: number[], tokens: Token[]): AstNode {\r\n    const start = 0;\r\n\r\n    let leftNode: AstNode | null = null;\r\n    for (let i = 0; i < indexes.length; i++) {\r\n      const opToken = getTokenValue(tokens[indexes[i]]) as ComparisonOperators;\r\n      leftNode = leftNode\r\n        ? leftNode\r\n        : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]));\r\n\r\n      const endInd = i + 1 < indexes.length ? indexes[i + 1] : tokens.length;\r\n      const rightNode = this.createExpressionNode(\r\n        this.sliceWithBrackets(tokens, indexes[i] + 1, endInd)\r\n      );\r\n\r\n      leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    return leftNode as AstNode;\r\n  }\r\n\r\n  private groupLogicalOperations(logicOp: number[], tokens: Token[]): LogicalOpNode {\r\n    let start = 0;\r\n    const logicItems: LogicalNodeItem[] = [];\r\n    for (let i = 0; i < logicOp.length; i++) {\r\n      const opToken = tokens[logicOp[i]];\r\n      const logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);\r\n      logicItems.push({\r\n        node: this.createExpressionNode(logicalSlice),\r\n        op: getTokenValue(opToken) as LogicalOperators\r\n      });\r\n\r\n      start = logicOp[i] + 1;\r\n    }\r\n\r\n    logicItems.push({\r\n      node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))\r\n    } as LogicalNodeItem);\r\n\r\n    const lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));\r\n    return lop;\r\n  }\r\n\r\n  private tokensToInstructionLines(tokens: Token[], startLine: number): InstructionLine[] {\r\n    const lines: InstructionLine[] = [];\r\n\r\n    let column = 0;\r\n    let currentLine = startLine;\r\n    let line = new InstructionLine();\r\n    for (let i = 0; i < tokens.length; i++) {\r\n      const token = tokens[i];\r\n      const sLine = getStartLine(token);\r\n      const sColumn = getStartColumn(token);\r\n      const value = getTokenValue(token);\r\n      this._currentToken = token;\r\n\r\n      if (sLine >= startLine) {\r\n        if (currentLine !== sLine) {\r\n          currentLine = sLine;\r\n        }\r\n\r\n        if (column === sColumn && !')}]'.includes(value as string)) {\r\n          currentLine = sLine;\r\n          lines.push(line);\r\n          line = new InstructionLine();\r\n        }\r\n\r\n        line.tokens.push(token);\r\n\r\n        // first line defines a minimum indent\r\n        if (column === 0) {\r\n          column = sColumn;\r\n        }\r\n\r\n        // stop looping through if line has less indent\r\n        // it means the corrent block finished\r\n        if (sColumn < column) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (line.tokens.length) {\r\n      lines.push(line);\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  private createExpressionNode(tokens: Token[]): AstNode {\r\n    if (tokens.length === 0) {\r\n      throw new Error(`Tokens length can't empty.`);\r\n    }\r\n    const lastToken = tokens[tokens.length - 1];\r\n    if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {\r\n      throw new Error(`Unexpected symbol ';' in the end`);\r\n    }\r\n\r\n    this._currentToken = tokens[0];\r\n\r\n    // const or variable\r\n    if (tokens.length === 1 || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')) {\r\n      const firstToken = tokens[0];\r\n      const tokenType = getTokenType(firstToken);\r\n\r\n      if (isTokenTypeLiteral(tokenType)) {\r\n        return new ConstNode(firstToken);\r\n      } else if (tokenType === TokenTypes.Identifier) {\r\n        return new GetSingleVarNode(\r\n          firstToken,\r\n          (tokens.length === 2 && getTokenValue(tokens[1]) === '?') || undefined\r\n        );\r\n      }\r\n\r\n      throw Error(`Unhandled single token: '${JSON.stringify(firstToken)}'`);\r\n    }\r\n\r\n    // arrow function\r\n    const arrowFuncParts = splitTokens(tokens, '=>');\r\n    if (arrowFuncParts.length > 1) {\r\n      const pArray =\r\n        getTokenValue(arrowFuncParts[0][0]) === '('\r\n          ? arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)\r\n          : arrowFuncParts[0];\r\n      const params = splitTokens(pArray, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n      const instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);\r\n      const funcAst = {\r\n        name: this._moduleName,\r\n        body: [] as AstNode[],\r\n        funcs: [] as AstNode[]\r\n      } as AstBlock;\r\n      this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n      return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    // comparison operations\r\n    const comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);\r\n    if (comparissonIndexes.length) {\r\n      return this.groupComparisonOperations(comparissonIndexes, tokens);\r\n    }\r\n\r\n    // create arithmetic expression\r\n    const ops = findOperators(tokens);\r\n    if (ops.length) {\r\n      let prevNode: AstNode | null = null;\r\n      for (let i = 0; i < ops.length; i++) {\r\n        const opIndex = ops[i];\r\n        const op = getTokenValue(tokens[opIndex]) as Operators;\r\n\r\n        let nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n        let nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n        if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {\r\n          let rightNode: AstNode | null = null;\r\n          // iterate through all continuous '*', '/' operations\r\n          do {\r\n            const nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;\r\n\r\n            const leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);\r\n            const rightSlice2 = this.sliceWithBrackets(\r\n              tokens,\r\n              nextOpIndex + 1,\r\n              nextOpIndex2 || tokens.length\r\n            );\r\n\r\n            const left2 = this.createExpressionNode(leftSlice2);\r\n            const right2 = this.createExpressionNode(rightSlice2);\r\n            rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));\r\n\r\n            i++;\r\n            nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n            nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n          } while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'));\r\n\r\n          // add up result\r\n          if (prevNode === null) {\r\n            const leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);\r\n            prevNode = this.createExpressionNode(leftSlice);\r\n          }\r\n          prevNode = new BinOpNode(\r\n            prevNode,\r\n            op as ExpressionOperators,\r\n            rightNode,\r\n            getTokenLoc(tokens[0])\r\n          );\r\n        } else {\r\n          const leftSlice = prevNode ? [] : this.sliceWithBrackets(tokens, 0, opIndex);\r\n          const rightSlice = this.sliceWithBrackets(\r\n            tokens,\r\n            opIndex + 1,\r\n            nextOpIndex || tokens.length\r\n          );\r\n          const left: AstNode = prevNode || this.createExpressionNode(leftSlice);\r\n          const right = this.createExpressionNode(rightSlice);\r\n          prevNode = new BinOpNode(left, op as ExpressionOperators, right, getTokenLoc(tokens[0]));\r\n        }\r\n      }\r\n\r\n      if (prevNode === null) {\r\n        throw Error(`Can't create node ...`);\r\n      }\r\n\r\n      return prevNode;\r\n    }\r\n\r\n    // create chaining calls\r\n\r\n    const inds = findChainingCallTokensIndexes(tokens);\r\n\r\n    if (inds.length > 0) {\r\n      const chainingGroup = splitTokensByIndexes(tokens, inds);\r\n      const innerNodes: AstNode[] = [];\r\n\r\n      for (let i = 0; i < chainingGroup.length; i++) {\r\n        const chainLinkTokenks = chainingGroup[i];\r\n\r\n        if (i !== 0 && getTokenValue(chainLinkTokenks[0]) === '[') {\r\n          const nullCoelsing = getTokenValue(chainLinkTokenks[chainLinkTokenks.length - 1]) === '?';\r\n          if (nullCoelsing) {\r\n            chainLinkTokenks.pop();\r\n          }\r\n          const paramsTokensSlice = chainLinkTokenks.slice(1, chainLinkTokenks.length - 1);\r\n          const paramsNodes = this.createExpressionNode(paramsTokensSlice);\r\n\r\n          innerNodes.push(\r\n            new ChainingObjectAccessNode(\r\n              paramsNodes,\r\n              nullCoelsing,\r\n              getTokenLoc(chainLinkTokenks[0])\r\n            )\r\n          );\r\n          continue;\r\n        }\r\n\r\n        innerNodes.push(this.createExpressionNode(chainLinkTokenks));\r\n      }\r\n\r\n      return new ChainingCallsNode(innerNodes, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    // create function call node\r\n    if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {\r\n      const isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';\r\n      if (isNullCoelsing) {\r\n        // remove '?'\r\n        tokens.pop();\r\n      }\r\n      const name = getTokenValue(tokens[0]) as string;\r\n      const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n      const paramsTokens = splitTokens(paramsTokensSlice, ',');\r\n      const paramsNodes = paramsTokens.map(tkns => this.createExpressionNode(tkns));\r\n      const node = new FunctionCallNode(name, paramsNodes, getTokenLoc(tokens[0]));\r\n      node.nullCoelsing = isNullCoelsing || undefined;\r\n      return node;\r\n    }\r\n\r\n    // create Object Node\r\n    if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {\r\n      const keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');\r\n      const props = [] as ObjectPropertyInfo[];\r\n      for (let i = 0; i < keyValueTokens.length; i++) {\r\n        if (!keyValueTokens[i].length) {\r\n          continue;\r\n        }\r\n        const keyValue = splitTokens(keyValueTokens[i], ':');\r\n        if (keyValue.length === 1) {\r\n          const pInfo = {\r\n            name: new ConstNode(keyValue[0][0]),\r\n            value: this.createExpressionNode(keyValue[0])\r\n          } as ObjectPropertyInfo;\r\n\r\n          props.push(pInfo);\r\n        } else if (keyValue.length === 2) {\r\n          let name: AstNode | null = null;\r\n          const namePart = keyValue[0];\r\n\r\n          if (namePart.length === 1) {\r\n            name = new ConstNode(namePart[0]);\r\n          } else if (\r\n            getTokenValue(namePart[0]) === '[' &&\r\n            getTokenValue(namePart[namePart.length - 1]) === ']'\r\n          ) {\r\n            name = this.createExpressionNode(namePart.slice(1, namePart.length - 1));\r\n          } else {\r\n            throw new Error(\r\n              `Incorrect JSON. Can't resolve Key field. That should either constant or expression in []`\r\n            );\r\n          }\r\n\r\n          const pInfo = {\r\n            name,\r\n            value: this.createExpressionNode(keyValue[1])\r\n          } as ObjectPropertyInfo;\r\n\r\n          props.push(pInfo);\r\n        } else {\r\n          throw Error('Incorrect JSON');\r\n        }\r\n      }\r\n\r\n      return new CreateObjectNode(props, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    // create Array Node\r\n    if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {\r\n      const items = splitTokens(tokens.splice(1, tokens.length - 2), ',')\r\n        .filter(tkns => tkns?.length)\r\n        .map(tkns => this.createExpressionNode(tkns));\r\n\r\n      return new CreateArrayNode(items, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    throw Error(`Undefined node '${getTokenValue(tokens[0])}'.`);\r\n  }\r\n}\r\n","import { getTokenType, getTokenValue, Token, TokenTypes } from '../common';\r\n\r\nconst SeparatorsMap: Record<string, string[]> = {\r\n  '\\n': ['\\n'],\r\n  '=': ['=', '==', '=>'],\r\n\r\n  '+': ['+', '++', '+='],\r\n  '-': ['-', '--', '-='],\r\n  '*': ['*', '**', '*='],\r\n  '/': ['/', '//', '/='],\r\n\r\n  '.': ['.'],\r\n  '?': ['?'],\r\n  '!': ['!='],\r\n  ':': [':'],\r\n  ',': [','],\r\n\r\n  '>': ['>', '>='],\r\n  '<': ['<', '<=', '<>'],\r\n\r\n  '(': ['('],\r\n  ')': [')'],\r\n  '{': ['{'],\r\n  '}': ['}'],\r\n  '[': ['['],\r\n  ']': [']']\r\n};\r\n\r\nconst escapeChars = ['\"', \"'\", '\\\\'];\r\nconst Keywords: string[] = ['async', 'def', 'for', 'while', 'if', 'return', 'in'];\r\n\r\nexport class Tokenizer {\r\n  private _startLine = 1;\r\n  private _startColumn = 1;\r\n  private _currentLine = 1;\r\n  private _currentColumn = 1;\r\n  private _tokenText = '';\r\n  private _cursor = 0;\r\n  private _script = '';\r\n\r\n  private get tokenText(): string {\r\n    return this._tokenText;\r\n  }\r\n  private set tokenText(value: string) {\r\n    if (!this._tokenText && value) {\r\n      this._startLine = this._currentLine;\r\n      this._startColumn = this._currentColumn;\r\n    }\r\n    this._tokenText = value;\r\n  }\r\n\r\n  /**\r\n   * Splits script code into a tokens\r\n   * @param script A jsPython text\r\n   */\r\n  tokenize(script: string): Token[] {\r\n    if (!script || !script.length) {\r\n      return [];\r\n    }\r\n\r\n    script = script\r\n      // eslint-disable-next-line no-control-regex\r\n      .replace(new RegExp('\\t', 'g'), '  ') // replace all tabs with 2 spaces\r\n      // eslint-disable-next-line no-control-regex\r\n      .replace(new RegExp('\\r', 'g'), ''); // remove all \\r symbols\r\n    this._script = script;\r\n\r\n    this._cursor = 0;\r\n    this._startLine = 1;\r\n    this._startColumn = 1;\r\n    this._currentLine = 1;\r\n    this._currentColumn = 1;\r\n\r\n    const tokens: Token[] = [];\r\n\r\n    let first = true;\r\n    // handle initial spaces\r\n    while (script[this._cursor] === '\\n') {\r\n      this.incrementCursor();\r\n      if (first) {\r\n        this._currentLine++;\r\n        first = false;\r\n      }\r\n      this._currentColumn = 1;\r\n    }\r\n\r\n    do {\r\n      const symbol = script[this._cursor];\r\n\r\n      if (symbol == ' ' && this.tokenText.length !== 0) {\r\n        this.tokenText = this.processToken(this.tokenText, tokens);\r\n        continue;\r\n      } else if (SeparatorsMap[symbol] !== undefined && !this.isPartOfNumber(symbol, tokens)) {\r\n        // handle numbers with floating point e.g. 3.14\r\n        this.tokenText = this.processToken(this.tokenText, tokens);\r\n        this.tokenText = symbol;\r\n\r\n        const sepsMap = SeparatorsMap[symbol];\r\n\r\n        if (sepsMap.length >= 1) {\r\n          // process longer operators\r\n          while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {\r\n            this.tokenText += script[this.incrementCursor()];\r\n          }\r\n        }\r\n        this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);\r\n      } else if (symbol === '#') {\r\n        let first = true;\r\n        while (script[this.incrementCursor()] !== '\\n') {\r\n          this.tokenText += script[this._cursor];\r\n\r\n          // correct start column\r\n          if (first) {\r\n            first = false;\r\n            this._startColumn = this._startColumn - 1;\r\n          }\r\n\r\n          if (this._cursor + 1 >= script.length) break;\r\n        }\r\n        this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);\r\n      } else if (symbol === '\"' || symbol === \"'\") {\r\n        // remember either it is single or double quote\r\n        const q = symbol;\r\n        // we are not expecting token to be added here.\r\n        // it should pass a failt to parser\r\n        this.tokenText = this.processToken(this.tokenText, tokens);\r\n\r\n        // handle \"\"\" comment \"\"\"\"\r\n        if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {\r\n          const cLine = this._currentLine;\r\n          const cColumn = this._currentColumn;\r\n          this.incrementCursor(2);\r\n          const passCond = true;\r\n          while (passCond) {\r\n            this.tokenText += script[this.incrementCursor()];\r\n            if (\r\n              this._cursor + 3 >= script.length ||\r\n              (script[this._cursor + 1] === q &&\r\n                script[this._cursor + 2] === q &&\r\n                script[this._cursor + 3] === q)\r\n            ) {\r\n              break;\r\n            }\r\n          }\r\n          // a special case when multiline string\r\n          this._startLine = cLine;\r\n          this._startColumn = cColumn;\r\n\r\n          this.incrementCursor(3);\r\n        } else {\r\n          while (script[this.incrementCursor()] !== q) {\r\n            if (\r\n              script[this._cursor] === '\\\\' &&\r\n              escapeChars.indexOf(script[this._cursor + 1]) >= 0\r\n            ) {\r\n              this._cursor++;\r\n            }\r\n\r\n            this.tokenText += script[this._cursor];\r\n            if (this._cursor + 1 >= script.length) {\r\n              throw new Error(`Line ${this._startLine}: End of string missing.`);\r\n            }\r\n          }\r\n\r\n          //start column needs to take into account a begining quote, not just a string\r\n          this._startColumn--;\r\n        }\r\n\r\n        // a special case when empty string\r\n        if (this.tokenText.length === 0) {\r\n          this._startLine = this._currentLine;\r\n          this._startColumn = this._currentColumn;\r\n        }\r\n        this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);\r\n      } else if (symbol != ' ') {\r\n        this.tokenText += symbol;\r\n      }\r\n    } while (this.incrementCursor() < script.length);\r\n\r\n    this.processToken(this.tokenText, tokens);\r\n\r\n    return tokens;\r\n  }\r\n\r\n  private incrementCursor(count = 1): number {\r\n    for (let i = 0; i < count; i++) {\r\n      this._cursor = this._cursor + 1;\r\n      if (this._script[this._cursor] === '\\n') {\r\n        this._currentLine++;\r\n        this._currentColumn = 0;\r\n      } else {\r\n        this._currentColumn++;\r\n      }\r\n    }\r\n\r\n    return this._cursor;\r\n  }\r\n\r\n  private recognizeToken(\r\n    tokenText: string,\r\n    type: TokenTypes | null = null\r\n  ): { value: string | number | boolean | null; type: TokenTypes } {\r\n    let value: string | number | boolean | null = tokenText;\r\n\r\n    if (type === null) {\r\n      if (tokenText === 'null') {\r\n        type = TokenTypes.LiteralNull;\r\n        value = null;\r\n      } else if (tokenText === 'true' || tokenText === 'false') {\r\n        type = TokenTypes.LiteralBool;\r\n        value = tokenText === 'true';\r\n      } else if (this.parseNumberOrNull(tokenText) !== null) {\r\n        type = TokenTypes.LiteralNumber;\r\n        value = this.parseNumberOrNull(tokenText);\r\n      } else if (Keywords.indexOf(tokenText) >= 0) {\r\n        type = TokenTypes.Keyword;\r\n      } else {\r\n        type = TokenTypes.Identifier;\r\n      }\r\n    }\r\n\r\n    return {\r\n      value: value,\r\n      type: type\r\n    };\r\n  }\r\n\r\n  private processToken(\r\n    strToken: string,\r\n    tokens: Token[],\r\n    allowEmptyString = false,\r\n    type: TokenTypes | null = null\r\n  ): string {\r\n    // ignore empty tokens\r\n    if ((!strToken.length && !allowEmptyString) || strToken === '\\n') return '';\r\n\r\n    const token = this.recognizeToken(strToken, type);\r\n    tokens.push([\r\n      token.value,\r\n      Uint16Array.of(\r\n        token.type as number,\r\n        this._startLine,\r\n        this._startColumn,\r\n        this._currentLine,\r\n        this._currentColumn\r\n      )\r\n    ] as Token);\r\n    return '';\r\n  }\r\n\r\n  private parseNumberOrNull(value: string | number): number | null {\r\n    if (typeof value === 'number') {\r\n      return value;\r\n    }\r\n\r\n    if (!value || typeof value !== 'string') {\r\n      return null;\r\n    }\r\n\r\n    value = value.trim();\r\n\r\n    // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number\r\n    for (let i = value.length - 1; i >= 0; i--) {\r\n      const d = value.charCodeAt(i);\r\n      if (d < 48 || d > 57) {\r\n        // '.' - 46 ',' - 44 '-' - 45(but only first char)\r\n        if (d !== 46 && d !== 44 && (d !== 45 || i !== 0)) return null;\r\n      }\r\n    }\r\n\r\n    const res = parseFloat(value);\r\n    return !isNaN(res) ? res : null;\r\n  }\r\n\r\n  private isPartOfNumber(symbol: string, currentTokens: Token[]): boolean {\r\n    if (symbol === '-' && !this.tokenText.length) {\r\n      // '-' needs to be handled e.g. -3; 2 + -2 etc\r\n      const prevToken = currentTokens.length !== 0 ? currentTokens[currentTokens.length - 1] : null;\r\n      return (\r\n        prevToken === null ||\r\n        (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')')\r\n      );\r\n    } else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","import { AstBlock, ImportNode, Token } from './common';\r\nimport { getImportType } from './common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { EvaluatorAsync } from './evaluator/evaluatorAsync';\r\nimport { BlockContext, Scope } from './evaluator/scope';\r\nimport { INITIAL_SCOPE, PackageToImport } from './initialScope';\r\nimport { Parser } from './parser';\r\nimport { Tokenizer } from './tokenizer';\r\n\r\nexport type PackageLoader = (packageName: string) => Record<string, unknown>;\r\nexport type ModuleLoader = (filePath: string) => Promise<string>;\r\n\r\nexport function jsPython(): Interpreter {\r\n  return Interpreter.create();\r\n}\r\n\r\nexport class Interpreter {\r\n  private readonly initialScope: Record<string, unknown> = { ...INITIAL_SCOPE };\r\n\r\n  private _lastExecutionContext: Record<string, unknown> | null = null;\r\n\r\n  private packageLoader?: PackageLoader;\r\n  private moduleLoader?: ModuleLoader;\r\n\r\n  static create(): Interpreter {\r\n    return new Interpreter();\r\n  }\r\n\r\n  get initialExecutionContext(): Record<string, unknown> {\r\n    return this.initialScope;\r\n  }\r\n\r\n  get lastExecutionContext(): Record<string, unknown> | null {\r\n    return this._lastExecutionContext;\r\n  }\r\n\r\n  cleanUp(): void {\r\n    this._lastExecutionContext = null;\r\n  }\r\n\r\n  jsPythonInfo(): string {\r\n    return INITIAL_SCOPE.jsPython();\r\n  }\r\n\r\n  tokenize(script: string): Token[] {\r\n    const tokenizer = new Tokenizer();\r\n    return tokenizer.tokenize(script);\r\n  }\r\n\r\n  parse(script: string, moduleName = 'main.jspy'): AstBlock {\r\n    const tokenizer = new Tokenizer();\r\n    const parser = new Parser();\r\n    const jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);\r\n    return jspyAst;\r\n  }\r\n\r\n  eval(\r\n    codeOrAst: string | AstBlock,\r\n    scope: Record<string, unknown> = {},\r\n    entryFunctionName: string | [string, ...unknown[]] = '',\r\n    moduleName = 'main.jspy'\r\n  ): unknown {\r\n    const ast =\r\n      typeof codeOrAst === 'string'\r\n        ? this.parse(codeOrAst as string, moduleName)\r\n        : (codeOrAst as AstBlock);\r\n\r\n    const blockContext = {\r\n      moduleName: moduleName,\r\n      cancellationToken: { cancel: false },\r\n      blockScope: new Scope(scope)\r\n    } as BlockContext;\r\n\r\n    blockContext.blockScope.set('printExecutionContext', () =>\r\n      console.log(blockContext.blockScope.getScope())\r\n    );\r\n    blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n    this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n    const result = new Evaluator().evalBlock(ast, blockContext);\r\n    if (!entryFunctionName || !entryFunctionName.length) {\r\n      return result;\r\n    } else {\r\n      const funcName = Array.isArray(entryFunctionName)? entryFunctionName[0] : entryFunctionName as string\r\n      const funcParams = Array.isArray(entryFunctionName)? entryFunctionName.slice(1) : []\r\n      const func = blockContext.blockScope.get(funcName);\r\n      if (typeof func !== 'function') {\r\n        throw Error(`Function ${entryFunctionName} does not exists or not a function`);\r\n      }\r\n      return func(...funcParams);\r\n    }\r\n  }\r\n\r\n  async evalAsync(\r\n    codeOrAst: string | AstBlock,\r\n    scope: Record<string, unknown> = {},\r\n    entryFunctionName: string | [string, ...unknown[]] = '',\r\n    moduleName = 'main.jspy',\r\n    ctxInitialized?: (ctx: BlockContext) => void\r\n  ): Promise<unknown> {\r\n    const ast =\r\n      typeof codeOrAst === 'string'\r\n        ? this.parse(codeOrAst as string, moduleName)\r\n        : (codeOrAst as AstBlock);\r\n    const evaluator = new EvaluatorAsync();\r\n    const blockContext = {\r\n      moduleName: moduleName,\r\n      cancellationToken: { cancel: false },\r\n      blockScope: new Scope(scope)\r\n    } as BlockContext;\r\n\r\n    if (typeof ctxInitialized === 'function') {\r\n      ctxInitialized(blockContext);\r\n    }\r\n\r\n    blockContext.blockScope.set('printExecutionContext', () =>\r\n      console.log(blockContext.blockScope.getScope())\r\n    );\r\n    blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n    this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n    const result = await evaluator\r\n      .registerJsonFileLoader(\r\n        async (modulePath: string) =>\r\n          await (this.moduleLoader\r\n            ? this.moduleLoader(modulePath)\r\n            : Promise.reject('ModuleLoader is not registered'))\r\n      )\r\n      .registerModuleParser(async modulePath => await this.moduleParser(modulePath))\r\n      .registerBlockContextFactory((moduleName, ast: AstBlock) => {\r\n        // enrich context\r\n        const newContext = this.assignImportContext(ast, scope);\r\n        const moduleContext = {\r\n          moduleName,\r\n          blockScope: new Scope(newContext),\r\n          cancellationToken: blockContext.cancellationToken\r\n        };\r\n        moduleContext.blockScope.set('printExecutionContext', () =>\r\n          console.log(moduleContext.blockScope.getScope())\r\n        );\r\n        moduleContext.blockScope.set('getExecutionContext', () =>\r\n          moduleContext.blockScope.getScope()\r\n        );\r\n        return moduleContext;\r\n      })\r\n      .evalBlockAsync(ast, blockContext);\r\n\r\n    if (!entryFunctionName || !entryFunctionName.length) {\r\n      return result;\r\n    } else {\r\n      const funcName = Array.isArray(entryFunctionName)? entryFunctionName[0] : entryFunctionName as string\r\n      const funcParams = Array.isArray(entryFunctionName)? entryFunctionName.slice(1) : []\r\n\r\n      const func = blockContext.blockScope.get(funcName);\r\n      if (typeof func !== 'function') {\r\n        throw Error(`Function ${entryFunctionName} does not exists or not a function`);\r\n      }\r\n      return await func(...funcParams);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compatibility method (with v1). !\r\n   */\r\n  async evaluate(\r\n    script: string,\r\n    context: Record<string, unknown> = {},\r\n    entryFunctionName: string | [string, ...unknown[]] = '',\r\n    moduleName = 'main.jspy',\r\n    ctxInitialized?: (ctx: BlockContext) => void\r\n  ): Promise<unknown> {\r\n    if (!script || !script.length) {\r\n      return null;\r\n    }\r\n    const ast = this.parse(script, moduleName);\r\n\r\n    context = context && typeof context === 'object' ? context : {};\r\n    context = this.assignImportContext(ast, context);\r\n\r\n    const globalScope = {\r\n      ...this.initialScope,\r\n      ...context\r\n    } as Record<string, unknown>;\r\n\r\n    return await this.evalAsync(ast, globalScope, entryFunctionName, moduleName, ctxInitialized);\r\n  }\r\n\r\n  registerPackagesLoader(loader: PackageLoader): Interpreter {\r\n    if (typeof loader === 'function') {\r\n      this.packageLoader = loader;\r\n    } else {\r\n      throw Error('PackagesLoader');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  registerModuleLoader(loader: ModuleLoader): Interpreter {\r\n    if (typeof loader === 'function') {\r\n      this.moduleLoader = loader;\r\n    } else {\r\n      throw Error('ModuleLoader should be a function');\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  addFunction(\r\n    funcName: string,\r\n    fn: (...args: unknown[]) => void | unknown | Promise<unknown>\r\n  ): Interpreter {\r\n    this.initialScope[funcName] = fn;\r\n    return this;\r\n  }\r\n\r\n  assignGlobalContext(obj: Record<string, unknown>): Interpreter {\r\n    Object.assign(this.initialScope, obj);\r\n    return this;\r\n  }\r\n\r\n  hasFunction(scripts = '', funcName: string): boolean {\r\n    return scripts.indexOf(`def ${funcName}`) > -1;\r\n  }\r\n\r\n  assignImportContext(\r\n    ast: AstBlock,\r\n    context: Record<string, unknown>\r\n  ): Record<string, unknown> {\r\n    const nodeToPackage = (im: ImportNode): PackageToImport => {\r\n      return {\r\n        name: im.module.name,\r\n        as: im.module.alias,\r\n        properties: im.parts?.map(p => ({ name: p.name, as: p.alias }))\r\n      } as PackageToImport;\r\n    };\r\n\r\n    const importNodes = ast.body.filter(n => n.type === 'import') as ImportNode[];\r\n\r\n    const jsImport = importNodes\r\n      .filter(im => getImportType(im.module.name) === 'jsPackage')\r\n      .map(im => nodeToPackage(im));\r\n\r\n    if (jsImport.length && this.packageLoader) {\r\n      const libraries = this.packageResolver(jsImport);\r\n      context = { ...context, ...libraries };\r\n    }\r\n\r\n    return context as Record<string, unknown>;\r\n  }\r\n\r\n  private async moduleParser(modulePath: string): Promise<AstBlock> {\r\n    if (!this.moduleLoader) {\r\n      throw new Error('Module Loader is not registered');\r\n    }\r\n\r\n    const content = await this.moduleLoader(modulePath);\r\n    return this.parse(content, modulePath);\r\n  }\r\n\r\n  private packageResolver(packages: PackageToImport[]): Record<string, unknown> {\r\n    if (!this.packageLoader) {\r\n      throw Error('Package loader not provided.');\r\n    }\r\n    const libraries: Record<string, unknown> = {};\r\n    packages.forEach(({ name, as, properties }: PackageToImport) => {\r\n      const lib = (this.packageLoader && this.packageLoader(name)) || {};\r\n      if (properties?.length) {\r\n        properties.forEach(prop => {\r\n          libraries[prop.as || prop.name] = lib[prop.name];\r\n        });\r\n      } else if (as) {\r\n        libraries[as] = lib;\r\n      } else {\r\n        libraries[name] = lib;\r\n      }\r\n      if (as) {\r\n        libraries[as] = lib;\r\n      }\r\n    });\r\n    return libraries;\r\n  }\r\n}\r\n"],"names":["getImportType","name","startsWith","endsWith","jspyErrorMessage","error","module","line","column","message","concat","_super","JspyTokenizerError","_this","this","Object","setPrototypeOf","prototype","__extends","Error","OperationTypes","JspyParserError","JspyEvalError","JspyError","TokenTypes","OperatorsMap","Map","Arithmetic","Comparison","Logical","Membership","Assignment","OperationFuncs","l","r","arithmeticOperation","comparissonOperation","logicalOperation","op","includes","String","Array","isArray","membershipOperation","Math","pow","getTokenType","token","getTokenValue","getTokenLoc","subarray","getStartLine","getStartColumn","splitTokensByIndexes","tokens","sepIndexes","result","length","start","i","ind","push","slice","splitTokens","separator","findTokenValueIndexes","value","findTokenValueIndex","predicate","LiteralString","skipInnerBrackets","opIndexes","tValue","findOperators","operationType","get","has","openChar","closeChar","innerBrackets","tokenValue","AstNode","type","loc","undefined","AssignNode","target","source","call","ConstNode","CommentNode","comment","ReturnNode","returnValue","RaiseNode","errorName","errorMessageAst","ContinueNode","BreakNode","SetSingleVarNode","FunctionCallNode","paramNodes","nullCoelsing","FunctionDefNode","funcAst","params","isAsync","ArrowFuncDefNode","ElifNode","conditionNode","elifBody","IfNode","ifBody","elifs","elseBody","TryExceptNode","tryBody","exepts","finallyBody","ForNode","sourceArray","itemVarName","body","WhileNode","condition","ImportNode","parts","GetSingleVarNode","ChainingCallsNode","innerNodes","CreateObjectNode","props","CreateArrayNode","items","ChainingObjectAccessNode","indexerBody","LogicalOpNode","BinOpNode","left","right","cloneContext","context","moduleName","blockScope","clone","cancellationToken","Scope","initialScope","scope","__assign","getScope","set","key","Evaluator","evalBlock","ast","blockContext","lastResult","node","funcDef","args","_i","arguments","jspyFuncInvoker","apply","_a","funcs","cancel","evalNode","returnCalled","res","returnObject","continueCalled","breakCalled","err","assign","argValue","invokeFunction","func","fps","raiseNode","errorMessage","returnNode","name_2","charAt","binOpNode","logicalGroups","gResult","eg","arrowFuncDef_1","funcCallNode","pms","_g","map","n","assignNode","node_1","targetNode","targetObjectNode","targetObject","lastInnerNode","lastPropertyName","resolveChainingCallsNode","obj","_h","p","_j","_k","item","whileNode","forNode","array","tryNode","_b","name_1","_c","firstExept","catchBody","ctx","_d","alias","_e","_f","ifNode","doElse","elIfNode","chNode","startObject","nestedProp","bind","EvaluatorAsync","moduleParser","Promise","reject","jsonFileLoader","registerModuleParser","registerJsonFileLoader","registerBlockContextFactory","blockContextFactory","evalBlockAsync","newScope","invoker","jspyFuncInvokerAsync","__spreadArray","iType","importNode","JSON","parse","jsonValue","sent","defaultModuleName","moduleAst","moduleBlockContext","assignFunctionsToScope","evalNodeAsync","err_1","filter","f","indexOf","substring","lastIndexOf","invokeFunctionAsync","_0","err_2","_l","_o","_m","_p","_q","_r","_t","_s","_u","_v","_x","_w","_z","_y","INITIAL_SCOPE","jsPython","dateTime","str","Date","isNaN","valueOf","strValue","parseMonth","mm","NaN","m","parseInt","correctYear","yy","validDateOrNull","yyyy","month","day","hours","mins","ss","dd","strTokens","replace","toLowerCase","split","dt","parseFloat","d","parseDatetimeOrNull","range","stop","step","arr","isStopNaN","print","console","log","isNull","v","defValue","isDate","isFunction","isString","deleteProperty","propName","printExecutionContext","getExecutionContext","InstructionLine","startLine","startColumn","endLine","endColumn","Parser","_currentToken","_moduleName","instructions","tokensToInstructionLines","instructionsToNodes","getBody","startTokenIndex","instructionLines","bodyAst","findIndexes","tkns","operation","splice","forEach","instruction","tt","Comment","firstToken","secondToken","logicOpIndexes","funcName","findIndex","t","endDefOfDef","conditionTokens","groupLogicalOperations","createExpressionNode","elifNodes","elifInstruction","endOfElif","conditionTokens_1","elifConditionNode","excepts","endIndex","except","errMsg","forBody","asIndex","module_1","join","importIndex","module_2","assignTokens","sliceWithBrackets","a","begin","end","groupComparisonOperations","indexes","leftNode","opToken","endInd","rightNode","logicOp","logicItems","logicalSlice","lines","sLine","sColumn","lastToken","tokenType","LiteralNumber","LiteralBool","LiteralNull","isTokenTypeLiteral","Identifier","stringify","arrowFuncParts","comparissonIndexes","ops","prevNode","opIndex","nextOpIndex","nextOp","leftSlice","rightSlice","nextOpIndex2","leftSlice2","rightSlice2","left2","right2","inds","findChainingCallTokensIndexes","chainingGroup","chainLinkTokenks","pop","paramsTokensSlice","paramsNodes","isNullCoelsing","keyValueTokens","keyValue","pInfo","namePart","SeparatorsMap","escapeChars","Keywords","Tokenizer","_startLine","_startColumn","_currentLine","_currentColumn","_tokenText","_cursor","_script","defineProperty","tokenize","script","RegExp","first","incrementCursor","symbol","tokenText","isPartOfNumber","first_1","processToken","q","cLine","cColumn","sepsMap","Operator","count","recognizeToken","parseNumberOrNull","Keyword","strToken","allowEmptyString","Uint16Array","of","trim","charCodeAt","currentTokens","prevToken","Interpreter","_lastExecutionContext","create","cleanUp","jsPythonInfo","tokenizer","eval","codeOrAst","entryFunctionName","funcParams","evalAsync","ctxInitialized","evaluator","modulePath","__awaiter","moduleLoader","__generator","newContext","assignImportContext","moduleContext","evaluate","globalScope","registerPackagesLoader","loader","packageLoader","registerModuleLoader","addFunction","fn","assignGlobalContext","hasFunction","scripts","jsImport","im","as","properties","nodeToPackage","libraries","packageResolver","content","packages","lib","prop","exports"],"mappings":"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"}