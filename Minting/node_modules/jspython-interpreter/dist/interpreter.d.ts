import { AstBlock, Token } from './common';
import { BlockContext } from './evaluator/scope';
export type PackageLoader = (packageName: string) => Record<string, unknown>;
export type ModuleLoader = (filePath: string) => Promise<string>;
export declare function jsPython(): Interpreter;
export declare class Interpreter {
    private readonly initialScope;
    private _lastExecutionContext;
    private packageLoader?;
    private moduleLoader?;
    static create(): Interpreter;
    get initialExecutionContext(): Record<string, unknown>;
    get lastExecutionContext(): Record<string, unknown> | null;
    cleanUp(): void;
    jsPythonInfo(): string;
    tokenize(script: string): Token[];
    parse(script: string, moduleName?: string): AstBlock;
    eval(codeOrAst: string | AstBlock, scope?: Record<string, unknown>, entryFunctionName?: string | [string, ...unknown[]], moduleName?: string): unknown;
    evalAsync(codeOrAst: string | AstBlock, scope?: Record<string, unknown>, entryFunctionName?: string | [string, ...unknown[]], moduleName?: string, ctxInitialized?: (ctx: BlockContext) => void): Promise<unknown>;
    /**
     * Compatibility method (with v1). !
     */
    evaluate(script: string, context?: Record<string, unknown>, entryFunctionName?: string | [string, ...unknown[]], moduleName?: string, ctxInitialized?: (ctx: BlockContext) => void): Promise<unknown>;
    registerPackagesLoader(loader: PackageLoader): Interpreter;
    registerModuleLoader(loader: ModuleLoader): Interpreter;
    addFunction(funcName: string, fn: (...args: unknown[]) => void | unknown | Promise<unknown>): Interpreter;
    assignGlobalContext(obj: Record<string, unknown>): Interpreter;
    hasFunction(scripts: string | undefined, funcName: string): boolean;
    assignImportContext(ast: AstBlock, context: Record<string, unknown>): Record<string, unknown>;
    private moduleParser;
    private packageResolver;
}
//# sourceMappingURL=interpreter.d.ts.map